"use strict";(self.webpackChunkminimal_blog=self.webpackChunkminimal_blog||[]).push([[898],{1173:function(e,t,n){n.d(t,{p:function(){return p},A:function(){return m}});var a=n(454),r=n(6540),s=n(557),l=n(6835),o=n(3328),i=n(7715),c=n(7169);var h=e=>{let{post:t}=e;return null};const d=["16px","8px","4px"].map(e=>"rgba(0, 0, 0, 0.1) 0px "+e+" "+e+" 0px");var u=e=>{let{data:{post:t},children:n}=e;return(0,s.Y)(o.A,null,(0,s.Y)(l.DZ,{as:"h1",variant:"styles.h1"},t.title),(0,s.Y)("p",{sx:{color:"secondary",mt:3,a:{color:"secondary"},fontSize:[1,1,2]}},(0,s.Y)("time",null,t.date),t.tags&&(0,s.Y)(r.Fragment,null," — ",(0,s.Y)(i.A,{tags:t.tags})),t.timeToRead&&" — ",t.timeToRead&&(0,s.Y)("span",null,t.timeToRead," min read")),(0,s.Y)("section",{sx:{my:5,".gatsby-resp-image-wrapper":{my:[4,4,5],borderRadius:"4px",boxShadow:d.join(", "),".gatsby-resp-image-image":{borderRadius:"4px"}},variant:"layout.content"}},n),(0,s.Y)(h,{post:t}))};const p=e=>{var t,n,a;let{data:{post:r}}=e;return(0,s.Y)(c.A,{title:r.title,description:r.description?r.description:r.excerpt,image:r.banner?null===(t=r.banner)||void 0===t||null===(n=t.childImageSharp)||void 0===n||null===(a=n.resize)||void 0===a?void 0:a.src:void 0,pathname:r.slug,canonicalUrl:r.canonicalUrl})};function m(e){let t=Object.assign({},((0,a.A)(e),e));return r.createElement(u,t)}},2040:function(e,t,n){n.r(t),n.d(t,{Head:function(){return o.p},default:function(){return i}});var a=n(6540),r=n(8453);function s(e){const t=Object.assign({h2:"h2",p:"p",blockquote:"blockquote",ol:"ol",li:"li",strong:"strong",code:"code",pre:"pre",ul:"ul",span:"span",a:"a"},(0,r.RP)(),e.components);return a.createElement(a.Fragment,null,a.createElement(t.h2,null,"Introduction"),"\n",a.createElement(t.p,null,"GraphQL is a new API standard that provides a more efficient, powerful and flexible alternative to REST. It was developed and open-sourced by Facebook and is now maintained by a large community of companies and individuals from all over the world."),"\n",a.createElement(t.blockquote,null,"\n",a.createElement(t.p,null,"APIs have become ubiquitous components of software infrastructures. In short, an API defines how a client can load data from a server."),"\n"),"\n",a.createElement(t.p,null,"At its core, GraphQL enables declarative data fetching where a client can specify exactly what data it needs from an API. Instead of multiple endpoints that return fixed data structures, a GraphQL server only exposes a single endpoint and responds with precisely the data a client asked for."),"\n",a.createElement(t.p,null,"Most applications today have the need to fetch data from a server where that data is stored in a database. It’s the responsibility of the API to provide an interface to the stored data that fits an application’s needs. GraphQL is often confused with being a database technology. This is a misconception, GraphQL is a query language for APIs - not databases. In that sense it’s database agnostic and effectively can be used in any context where an API is used."),"\n",a.createElement(t.h2,null,"A more efficient Alternative to REST"),"\n",a.createElement(t.p,null,"REST has been a popular way to expose data from a server. When the concept of REST was developed, client applications were relatively simple and the development pace wasn’t nearly where it is today. REST thus was a good fit for many applications. However, the API landscape has radically changed over the last couple of years. In particular, there are three factors that have been challenging the way APIs are designed:"),"\n",a.createElement(t.ol,null,"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Increased mobile usage creates need for efficient data loading")," - Increased mobile usage, low-powered devices and sloppy networks were the initial reasons why Facebook developed GraphQL. GraphQL minimizes the amount of data that needs to be transferred over the network and thus majorly improves applications operating under these conditions."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Variety of different frontend frameworks and platforms")," - The heterogeneous landscape of frontend frameworks and platforms that run client applications makes it difficult to build and maintain one API that would fit the requirements of all. With GraphQL, each client can access precisely the data it needs."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Fast development & expectation for rapid feature development")," - Continuous deployment has become a standard for many companies, rapid iterations and frequent product updates are indispensable. With REST APIs, the way data is exposed by the server often needs to be modified to account for specific requirements and design changes on the client-side. This hinders fast development practices and product iterations."),"\n"),"\n",a.createElement(t.h2,null,"Data Fetching with REST vs GraphQL"),"\n",a.createElement(t.p,null,"With a REST API, you would typically gather the data by accessing multiple endpoints. In the example, these could be ",a.createElement(t.code,null,"/users/<id>")," endpoint to fetch the initial user data. Secondly, there’s likely to be a ",a.createElement(t.code,null,"/users/<id>/posts")," endpoint that returns all the posts for a user. The third endpoint will then be the ",a.createElement(t.code,null,"/users/<id>/followers")," that returns a list of followers per user. In GraphQL on the other hand, you’d simply send a single query to the GraphQL server that includes the concrete data requirements. The server then responds with a JSON object where these requirements are fulfilled."),"\n",a.createElement(t.p,null,"One of the most common problems with REST is that of over- and underfetching. This happens because the only way for a client to download data is by hitting endpoints that return fixed data structures. It’s very difficult to design the API in a way that it’s able to provide clients with their exact data needs."),"\n",a.createElement(t.p,null,"Overfetching means that a client downloads more information than is actually required in the app. Imagine for example a screen that needs to display a list of users only with their names. In a REST API, this app would usually hit the ",a.createElement(t.code,null,"/users")," endpoint and receive a JSON array with user data. This response however might contain more info about the users that are returned, e.g. their birthdays or addresses - information that is useless for the client because it only needs to display the users’ names."),"\n",a.createElement(t.p,null,"Another issue is underfetching and the n+1-requests problem. Underfetching generally means that a specific endpoint doesn’t provide enough of the required information. The client will have to make additional requests to fetch everything it needs. This can escalate to a situation where a client needs to first download a list of elements, but then needs to make one additional request per element to fetch the required data."),"\n",a.createElement(t.p,null,"As an example, consider the same app would also need to display the last three followers per user. The API provides the additional endpoint ",a.createElement(t.code,null,"/users/<user-id>/followers"),". In order to be able to display the required information, the app will have to make one request to the ",a.createElement(t.code,null,"/users")," endpoint and then hit the ",a.createElement(t.code,null,"/users/<user-id>/followers")," endpoint for each user."),"\n",a.createElement(t.p,null,"GraphQL uses a strong type system to define the capabilities of an API. All the types that are exposed in an API are written down in a schema using the GraphQL Schema Definition Language (SDL). This schema serves as the contract between the client and the server to define how a client can access the data."),"\n",a.createElement(t.p,null,"Once the schema is defined, the teams working on frontend and backends can do their work without further communication since they both are aware of the definite structure of the data that’s sent over the network. Frontend teams can easily test their applications by mocking the required data structures. Once the server is ready, the switch can be flipped for the client apps to load the data from the actual API."),"\n",a.createElement(t.h2,null,"The Schema Definition Language (SDL)"),"\n",a.createElement(t.p,null,"GraphQL has its own type system that’s used to define the schema of an API. The syntax for writing schemas is called Schema Definition Language (SDL). Here is an example of how we can use the SDL to define a simple type called Person:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-graphql"},"type Person {\n  name: String!\n  age: Int!\n}\n")),"\n",a.createElement(t.p,null,"This type has two fields, they’re called name and age and are respectively of type String and Int. The ! following the type means that this field is required. It’s also possible to express relationships between types. In the example of a blogging application, a Person could be associated with a Post. Conversely, the other end of the relationship needs to be placed on the Person type:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-graphql"},"type Post {\n  title: String!\n  author: Person!\n}\n\ntype Person {\n  name: String!\n  age: Int!\n  posts: [Post!]!\n}\n")),"\n",a.createElement(t.h2,null,"Fetching Data with Queries"),"\n",a.createElement(t.p,null,"When working with REST APIs, data is loaded from specific endpoints. Each endpoint has a clearly defined structure of the information that it returns. This means that the data requirements of a client are effectively encoded in the URL that it connects to."),"\n",a.createElement(t.p,null,"The approach that’s taken in GraphQL is radically different. Instead of having multiple endpoints that return fixed data structures, GraphQL APIs typically only expose a single endpoint. This works because the structure of the data that’s returned is not fixed. Instead, it’s completely flexible and lets the client decide what data is actually needed. That means that the client needs to send more information to the server to express its data needs - this information is called a query."),"\n",a.createElement(t.p,null,"Let’s take a look at an example query that a client could send to a server:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-graphql"},"{\n  allPersons {\n    name\n  }\n}\n")),"\n",a.createElement(t.p,null,"The allPersons field in this query is called the ",a.createElement(t.strong,null,"root field")," of the query. Everything that follows the root field, is called the ",a.createElement(t.strong,null,"payload")," of the query. The only field that’s specified in this query’s payload is name. This query would return a list of all persons currently stored in the database. Here’s an example response:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-graphql"},'{\n  "allPersons": [\n    { "name": "Johnny" },\n    { "name": "Sarah" },\n    { "name": "Alice" }\n  ]\n}\n')),"\n",a.createElement(t.p,null,"Notice that each person only has the name in the response, but the age is not returned by the server. That’s exactly because name was the only field that was specified in the query. If the client also needed the persons’ age, all it has to do is slightly adjust the query and include the new field in the query’s payload. One of the major advantages of GraphQL is that it allows for naturally querying nested information. For example, if we wanted to load all the posts that a Person has written, we could simply follow the structure of our types to request this information. In GraphQL, each field can have zero or more arguments if that’s specified in the schema. For example, the allPersons field could have a last parameter to only return up to a specific number of persons. Here’s what a corresponding query would look like:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-graphql"},"{\n  allPersons(last: 2) {\n    name\n    posts {\n        title\n    }\n  }\n}\n")),"\n",a.createElement(t.h2,null,"Writing Data with Mutations"),"\n",a.createElement(t.p,null,"Next to requesting information from a server, the majority of applications also need some way of making changes to the data that’s currently stored in the backend. With GraphQL, these changes are made using so-called mutations. There generally are three kinds of mutations:"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"creating new data"),"\n",a.createElement(t.li,null,"updating existing data"),"\n",a.createElement(t.li,null,"deleting existing data\nMutations follow the same syntactical structure as queries, but they always need to start with the mutation keyword. Here’s an example for how we might create a new Person:"),"\n"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-graphql"},'mutation {\n  createPerson(name: "Bob", age: 36) {\n    id\n    name\n    age\n  }\n}\n')),"\n",a.createElement(t.p,null,"Like with a query, we’re also able to specify a payload for a mutation in which we can ask for different properties of the new Person object. In our case, we’re asking for the name and the age - though admittedly that’s not super helpful in our example since we obviously already know them as we pass them into the mutation. However, being able to also query information when sending mutations can be a very powerful tool that allows us to retrieve new information from the server in a single roundtrip. One pattern you’ll often find is that GraphQL types have unique IDs that are generated by the server when new objects are created."),"\n",a.createElement(t.h2,null,"Realtime Updates with Subscriptions"),"\n",a.createElement(t.p,null,"Another important requirement for many applications today is to have a realtime connection to the server in order to get immediately informed about important events. For this use case, GraphQL offers the concept of subscriptions."),"\n",a.createElement(t.p,null,"When a client subscribes to an event, it will initiate and hold a steady connection to the server. Whenever that particular event then actually happens, the server pushes the corresponding data to the client. Unlike queries and mutations that follow a typical “request-response-cycle”, subscriptions represent a stream of data sent over to the client. Subscriptions are written using the same syntax as queries and mutations. Here’s an example where we subscribe on events happening on the Person type:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-graphql"},"subscription {\n  newPerson {\n    name\n    age\n  }\n}\n")),"\n",a.createElement(t.p,null,"After a client sent this subscription to a server, a connection is opened between them. Then, whenever a new mutation is performed that creates a new Person, the server sends the information about this person over to the client."),"\n",a.createElement(t.h2,null,"Defining a Schema"),"\n",a.createElement(t.p,null,"The schema is one of the most important concepts when working with a GraphQL API. It specifies the capabilities of the API and defines how clients can request the data. It is often seen as a contract between the server and client."),"\n",a.createElement(t.p,null,"Generally, a schema is simply a collection of GraphQL types. However, when writing the schema for an API, there are some special root types:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-graphql"},"type Query { ... }\ntype Mutation { ... }\ntype Subscription { ... }\n")),"\n",a.createElement(t.p,null,"The Query, Mutation, and Subscription types are the entry points for the requests sent by the client. Putting it all together, this is the full schema for all the queries and mutation seen so far:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-graphql"},"type Query {\n  allPersons(last: Int): [Person!]!\n  allPosts(last: Int): [Post!]!\n}\n\ntype Mutation {\n  createPerson(name: String!, age: Int!): Person!\n  updatePerson(id: ID!, name: String!, age: String!): Person!\n  deletePerson(id: ID!): Person!\n}\n\ntype Subscription {\n  newPerson: Person!\n}\n\ntype Person {\n  id: ID!\n  name: String!\n  age: Int!\n  posts: [Post!]!\n}\n\ntype Post {\n  title: String!\n  author: Person!\n}\n")),"\n",a.createElement(t.h2,null,"Resolver Functions"),"\n",a.createElement(t.p,null,"The payload of a GraphQL query (or mutation) consists of a set of fields. In the GraphQL server implementation, each of these fields actually corresponds to exactly one function that’s called a resolver. The sole purpose of a resolver function is to fetch the data for its field."),"\n",a.createElement(t.p,null,"When the server receives a query, it will call all the functions for the fields that are specified in the query’s payload. It thus resolves the query and is able to retrieve the correct data for each field. Once all resolvers returned, the server will package data up in the format that was described by the query and send it back to the client."),"\n",a.createElement(t.p,null,"A resolver function receives four arguments:"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"obj")," - The previous object, which for a field on the root Query type is often not used."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"args")," The arguments provided to the field in the GraphQL query."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"context")," A value which is provided to every resolver and holds important contextual information like the currently logged in user, or access to a database."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"info")," A value which holds field-specific information relevant to the current query as well as the schema details\n",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 24.583333333333336%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA2UlEQVR42jVPSW7EMAzL///QU269FUXQU16QPyQeuxe3mdjjXd5STtoKEExapAgNtdbzPGupUn37GFMirbW1tpTSWosxAkATQhBCSClTTLGkU9a3l9dhWRaI4A81cfdlU3SBIK2t9t49BbhhcM4qpfD/TLryPt6nYZ5nIOiwX2fXev+lz6f13Wl7GHt/HOp4GGOsRRIRYThN07BtG1DOueRScsYAxnZVLcWQ94gL5NCBWm6UCbf8mbEOxHufUrpfBRr+i3POxI2LT46Lb4Izzhhb13Xf93EcfwCqzhpncXGwVQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="Resolver Functions"\n        title="Resolver Functions"\n        src="/ruminations/static/13ffcd7d700dcc666aa77ffd848a0daa/7d769/resolverfunctions.png"\n        srcset="/ruminations/static/13ffcd7d700dcc666aa77ffd848a0daa/5243c/resolverfunctions.png 240w,\n/ruminations/static/13ffcd7d700dcc666aa77ffd848a0daa/ab158/resolverfunctions.png 480w,\n/ruminations/static/13ffcd7d700dcc666aa77ffd848a0daa/7d769/resolverfunctions.png 960w,\n/ruminations/static/13ffcd7d700dcc666aa77ffd848a0daa/b050c/resolverfunctions.png 1054w"\n        sizes="(max-width: 960px) 100vw, 960px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>'}})),"\n"),"\n",a.createElement(t.h2,null,"More GraphQL Concepts"),"\n",a.createElement(t.p,null,"Fragments are a handy feature to help to improve the structure and reusability of your GraphQL code. A fragment is a collection of fields on a specific type. Fragments let us construct sets of fields, and then include them in queries where we need to. Example:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-graphql"},"fragment addressDetails on User {\n  name\n  street\n  zipcode\n  city\n}\n\n{\n  allUsers {\n    ... addressDetails\n  }\n}\n")),"\n",a.createElement(t.p,null,"In GraphQL type definitions, each field can take zero or more arguments. Similar to arguments that are passed into functions in typed programming languages, each argument needs to have a name and a type. In GraphQL, it’s also possible to specify default values for arguments. One of GraphQL’s major strengths is that it lets us send multiple queries in a single request. However, since the response data is shaped after the structure of the fields being requested, we may run into naming issues when we’re sending multiple queries asking for the same fields. The only way to send a query like that would be to use aliases, i.e. specifying names for the query results."),"\n",a.createElement(t.p,null,"In GraphQL, there are two different kinds of types."),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Scalar")," types represent concrete units of data. The GraphQL spec has five predefined scalars: as String, Int, Float, Boolean, and ID."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Object")," types have fields that express the properties of that type and are composable. Examples of object types are the User or Post types seen earlier."),"\n"),"\n",a.createElement(t.p,null,"In every GraphQL schema, we can define your own scalar and object types. An often cited example for a custom scalar would be a Date type where the implementation needs to define how that type is validated, serialized, and deserialized. GraphQL allows us to define enumerations types (short enums), a language feature to express the semantics of a type that has a fixed set of values. Note that technically enums are special kinds of scalar types. Union types can be used to express that a type should be either of a collection of other types."),"\n",a.createElement(t.p,null,"An interface can be used to describe a type in an abstract way. It allows us to specify a set of fields that any concrete type, which implements this interface, needs to have. In many GraphQL schemas, every type is required to have an id field. Using interfaces, this requirement can be expressed by defining an interface with this field and then making sure that all custom types implement it:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-graphql"},"interface Node {\n  id: ID!\n}\n\ntype User implements Node {\n  id: ID!\n  name: String!\n  age: Int!\n}\n")),"\n",a.createElement(t.h2,null,"Credits & Attributions:"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,a.createElement(t.a,{href:"https://graphql.org"},"Official GraphQL Documentation")),"\n",a.createElement(t.li,null,a.createElement(t.a,{href:"https://www.howtographql.com"},"How to GraphQL Tutorial")),"\n"))}var l=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,r.RP)(),e.components);return t?a.createElement(t,e,a.createElement(s,e)):s(e)},o=n(1173);function i(e){return a.createElement(o.A,e,a.createElement(l,e))}o.A},7715:function(e,t,n){var a=n(557),r=n(6540),s=n(4794),l=n(3601),o=n(2174);t.A=e=>{let{tags:t}=e;const{tagsPath:n,basePath:i}=(0,l.A)();return(0,a.Y)(r.Fragment,null,t.map((e,t)=>(0,a.Y)(r.Fragment,{key:e.slug},!!t&&", ",(0,a.Y)(s.Link,{sx:e=>{var t;return Object.assign({},null===(t=e.styles)||void 0===t?void 0:t.a)},to:(0,o.A)("/"+i+"/"+n+"/"+e.slug)},e.name))))}}}]);
//# sourceMappingURL=component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx-content-file-path-content-posts-graphql-basics-index-mdx-64fc132fc56c68d21b9c.js.map