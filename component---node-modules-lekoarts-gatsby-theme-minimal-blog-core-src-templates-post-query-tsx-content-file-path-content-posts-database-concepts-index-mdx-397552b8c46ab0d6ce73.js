"use strict";(self.webpackChunkminimal_blog=self.webpackChunkminimal_blog||[]).push([[348],{1173:function(e,t,n){n.d(t,{p:function(){return h},A:function(){return E}});var a=n(454),l=n(6540),r=n(557),s=n(6835),o=n(3328),i=n(7715),c=n(7169);var u=e=>{let{post:t}=e;return null};const d=["16px","8px","4px"].map(e=>"rgba(0, 0, 0, 0.1) 0px "+e+" "+e+" 0px");var m=e=>{let{data:{post:t},children:n}=e;return(0,r.Y)(o.A,null,(0,r.Y)(s.DZ,{as:"h1",variant:"styles.h1"},t.title),(0,r.Y)("p",{sx:{color:"secondary",mt:3,a:{color:"secondary"},fontSize:[1,1,2]}},(0,r.Y)("time",null,t.date),t.tags&&(0,r.Y)(l.Fragment,null," — ",(0,r.Y)(i.A,{tags:t.tags})),t.timeToRead&&" — ",t.timeToRead&&(0,r.Y)("span",null,t.timeToRead," min read")),(0,r.Y)("section",{sx:{my:5,".gatsby-resp-image-wrapper":{my:[4,4,5],borderRadius:"4px",boxShadow:d.join(", "),".gatsby-resp-image-image":{borderRadius:"4px"}},variant:"layout.content"}},n),(0,r.Y)(u,{post:t}))};const h=e=>{var t,n,a;let{data:{post:l}}=e;return(0,r.Y)(c.A,{title:l.title,description:l.description?l.description:l.excerpt,image:l.banner?null===(t=l.banner)||void 0===t||null===(n=t.childImageSharp)||void 0===n||null===(a=n.resize)||void 0===a?void 0:a.src:void 0,pathname:l.slug,canonicalUrl:l.canonicalUrl})};function E(e){let t=Object.assign({},((0,a.A)(e),e));return l.createElement(m,t)}},7715:function(e,t,n){var a=n(557),l=n(6540),r=n(4794),s=n(3601),o=n(2174);t.A=e=>{let{tags:t}=e;const{tagsPath:n,basePath:i}=(0,s.A)();return(0,a.Y)(l.Fragment,null,t.map((e,t)=>(0,a.Y)(l.Fragment,{key:e.slug},!!t&&", ",(0,a.Y)(r.Link,{sx:e=>{var t;return Object.assign({},null===(t=e.styles)||void 0===t?void 0:t.a)},to:(0,o.A)("/"+i+"/"+n+"/"+e.slug)},e.name))))}},9027:function(e,t,n){n.r(t),n.d(t,{Head:function(){return o.p},default:function(){return i}});var a=n(6540),l=n(8453);function r(e){const t=Object.assign({h2:"h2",p:"p",ol:"ol",li:"li",strong:"strong",h3:"h3",pre:"pre",code:"code",ul:"ul",h4:"h4",a:"a"},(0,l.RP)(),e.components);return a.createElement(a.Fragment,null,a.createElement(t.h2,null,"Introduction"),"\n",a.createElement(t.p,null,"Databases are used to store information. We take information from some source and put it in database where it gets persisted in either memory or hard disk and we eventually retrieve that data at some point in time. Database clients are used to connect to databases. SQL is a programming language used to interact with databases."),"\n",a.createElement(t.p,null,"Simple database design process questions:"),"\n",a.createElement(t.ol,null,"\n",a.createElement(t.li,null,"What kind of thing are we storing?"),"\n",a.createElement(t.li,null,"What properties does this thing have?"),"\n",a.createElement(t.li,null,"What type of data does each of those properties contain?"),"\n"),"\n",a.createElement(t.h2,null,"Tables"),"\n",a.createElement(t.p,null,"A table is a collection of records that are related to each other. A table is made up of columns and rows. ",a.createElement(t.strong,null,"Columns")," are also called fields and ",a.createElement(t.strong,null,"rows")," are also called records. A table is also called a ",a.createElement(t.strong,null,"relation"),". In relational databases, and flat file databases, a table is a set of data elements (values) using a model of vertical columns (identifiable by name) and horizontal rows, the cell being the unit where a row and column intersect. A table has a specified number of columns, but can have any number of rows. Columns store some information about specific properties of records. Rows represent a single, implicitly structured data item in a table."),"\n",a.createElement(t.h3,null,"Creating a table and inserting data"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-sql"},"-- Create a table called tablename1, with the two columns shown, for\n-- the database currently in use. Lots of other options are available\n-- for how you specify the columns, such as their datatypes.\nCREATE TABLE tablename1 (fname VARCHAR(20), lname VARCHAR(20));\n\n-- Insert a row of data into the table tablename1. This assumes that the\n-- table has been defined to accept these values as appropriate for it.\nINSERT INTO tablename1 VALUES('Richard','Mutt');\n-- another format: INSERT INTO tablename1 (fname, lname) VALUES('Richard','Mutt');\n\n-- inserting multiple rows:\nINSERT INTO tablename1 VALUES('Ethan','Hunt'),('Marcel','Duchamp');\n\n")),"\n",a.createElement(t.p,null,"SQL statements consist of Keywords, Options, and Identifiers. ",a.createElement(t.strong,null,"Keywords")," are the words that make up the SQL statement, which specify what needs to be done on the database. ",a.createElement(t.strong,null,"Options")," are the words that modify the statement. ",a.createElement(t.strong,null,"Identifiers")," are the names of the things that the statement is acting on. SQL is not just about pulling raw data out of a table, but it can also transform or process data before we retrieve it. For any SQL statement, the database first considers the data source, applies the filter criteria, and then selects and retrieves specified columns from the data source."),"\n",a.createElement(t.h3,null,"Retrieving, updating and deleting data from a table"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-sql"},"-- Select all rows and columns from the current database's departments table.\n-- Default activity is for the interpreter to scroll the results on your screen.\nSELECT * FROM departments;\n\n-- Retrieve all rows from the departments table, but only the dept_no and dept_name columns.\n-- Splitting up commands across lines is OK.\nSELECT dept_no, dept_name FROM departments;\n\n-- Retrieve all departments columns, but just 5 rows.\nSELECT * FROM departments LIMIT 5;\n\n-- Retrieve dept_name column values from the departments\n-- table where the dept_name value has the substring 'en'.\nSELECT dept_name FROM departments WHERE dept_name LIKE '%en%';\n\n-- Retrieve all columns from the departments table where the dept_name\n-- column starts with an 'S' and has exactly 4 characters after it.\nSELECT * FROM departments WHERE dept_name LIKE 'S____';\n\n-- Select title values from the titles table but don't show duplicates.\nSELECT DISTINCT title FROM titles;\n\n-- Same as above, but sorted (case-sensitive) by the title values.\nSELECT DISTINCT title FROM titles ORDER BY title;\n\n-- Show the number of rows in the departments table.\nSELECT COUNT(*) FROM departments;\n\n-- Show the number of rows in the departments table that\n-- have 'en' as a substring of the dept_name value.\nSELECT COUNT(*) FROM departments WHERE dept_name LIKE '%en%';\n\n-- In tablename1, change the fname value to 'John'\n-- for all rows that have an lname value of 'Mutt'.\nUPDATE tablename1 SET fname='John' WHERE lname='Mutt';\n\n-- Delete rows from the tablename1 table\n-- where the lname value begins with 'M'.\nDELETE FROM tablename1 WHERE lname LIKE 'M%';\n\n-- Delete all rows from the tablename1 table, leaving the empty table.\nDELETE FROM tablename1;\n\n-- Remove the entire tablename1 table.\nDROP TABLE tablename1;\n")),"\n",a.createElement(t.h2,null,"Table relationships"),"\n",a.createElement(t.p,null,"Relationship types between tables: one-to-one, one-to-many, many-to-one, many-to-many."),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Primary Key")," - uniquely identifies a record in the table. Each row in every table has one primary key, which never changes."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Foreign Key")," - identifies a record (usually in another table) that a particular row is associated with. The 'many' side of the relationship usually gets the foreign key column. Many rows in the same table can have the same foreign key, which can change if the relationship changes."),"\n"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-sql"},"-- Foreign Key example\nCREATE TABLE photos (\n    id SERIAL PRIMARY KEY,\n    url VARCHAR(200),\n    user_id INTEGER REFERENCES users(id)\n);\n-- SERIAL datatype in Postgres automatically generates integer values for specified column, starting from 1.\n")),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Data consistency")," - the state of the data in a database when all foreign key references are valid. If a foreign key references a primary key that doesn't exist, the data is inconsistent."),"\n",a.createElement(t.p,null,"There are some deletion constraints that can be used in foreign key references:"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,a.createElement(t.code,null,"ON DELETE RESTRICT")," - the default, which prevents deletion of a row if it is referenced by a foreign key in another table and throws an error"),"\n",a.createElement(t.li,null,a.createElement(t.code,null,"ON DELETE NO ACTION")," - same as RESTRICT"),"\n",a.createElement(t.li,null,a.createElement(t.code,null,"ON DELETE CASCADE")," - deletes all rows that reference the deleted row"),"\n",a.createElement(t.li,null,a.createElement(t.code,null,"ON DELETE SET NULL")," - sets the foreign key value to NULL for all rows that reference the deleted row"),"\n",a.createElement(t.li,null,a.createElement(t.code,null,"ON DELETE SET DEFAULT")," - sets the foreign key value to the default value for all rows that reference the deleted row"),"\n"),"\n",a.createElement(t.h3,null,"SQL joins"),"\n",a.createElement(t.ol,null,"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Inner join")," - returns rows that have matching values in both tables involved in the join. The join condition is specified in the WHERE clause. The INNER keyword is optional. It is the default join type."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Left outer join")," - returns all rows from the left table, and the matched rows from the right table. Null values are returned for the right table if there is no match."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Right outer join")," - returns all rows from the right table, and the matched rows from the left table. Null values are returned for the left table if there is no match."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Full outer join")," - returns all rows from both tables, regardless of whether there is a match or not. If there is no match, NULL values are used."),"\n"),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Joins")," - produce values by merging together rows from different related tables. Joins are used most of times when we are asked to find data that involves multiple resources."),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Aggregation")," - looks at many rows and calculates a single value. Words like 'sum', 'average', 'maximum', 'minimum', 'count' are used in aggregation."),"\n",a.createElement(t.p,null,'Table order between "FROM" and "JOIN" frequently makes a difference. We must give context if column names collide during joins. Tables can be renamed during joins using the "AS" keyword.'),"\n",a.createElement(t.h2,null,"Grouping and Aggregation"),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Grouping")," - divides rows into groups and applies an aggregate function to each group. The ",a.createElement(t.code,null,"GROUP BY")," clause is used to group rows together. The ",a.createElement(t.code,null,"GROUP BY")," clause must be after the ",a.createElement(t.code,null,"FROM")," and ",a.createElement(t.code,null,"WHERE")," clauses, but before the ",a.createElement(t.code,null,"ORDER BY")," clause. The ",a.createElement(t.code,null,"GROUP BY")," clause can group by multiple columns. The ",a.createElement(t.code,null,"GROUP BY")," clause can also group by column numbers instead of column names."),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Aggregation")," - looks at many rows and calculates a single value. Words like 'sum', 'average', 'maximum', 'minimum', 'count' are used in aggregation. The ",a.createElement(t.code,null,"HAVING")," clause is used to filter groups. The ",a.createElement(t.code,null,"HAVING")," clause must be after the ",a.createElement(t.code,null,"GROUP BY")," clause, but before the ",a.createElement(t.code,null,"ORDER BY")," clause. The ",a.createElement(t.code,null,"HAVING")," clause can use aggregate functions. The ",a.createElement(t.code,null,"HAVING")," clause can use column numbers instead of column names."),"\n",a.createElement(t.h3,null,"Sorting"),"\n",a.createElement(t.p,null,"The ",a.createElement(t.code,null,"ORDER BY")," clause is used to sort rows. The ",a.createElement(t.code,null,"ORDER BY")," clause must be after the ",a.createElement(t.code,null,"FROM"),", ",a.createElement(t.code,null,"WHERE"),", and ",a.createElement(t.code,null,"GROUP BY")," clauses, but before the ",a.createElement(t.code,null,"LIMIT")," clause. The ",a.createElement(t.code,null,"ORDER BY")," clause can sort by multiple columns, where column specification is considered as prioritization order. The ",a.createElement(t.code,null,"ORDER BY")," clause can sort by column numbers and expressions as well.\n",a.createElement(t.code,null,"LIMIT")," clause is used to limit the number of rows returned. ",a.createElement(t.code,null,"OFFSET")," clause is used to skip a specified number of rows before returning the rest."),"\n",a.createElement(t.h3,null,"Union and Intersection"),"\n",a.createElement(t.p,null,"The ",a.createElement(t.code,null,"UNION")," operator is used to combine the result-set of two or more ",a.createElement(t.code,null,"SELECT")," statements. Each ",a.createElement(t.code,null,"SELECT")," statement within ",a.createElement(t.code,null,"UNION")," must have the same number of columns. The columns must also have similar data types. The columns in each ",a.createElement(t.code,null,"SELECT")," statement must also be in the same order. The ",a.createElement(t.code,null,"UNION")," operator selects only distinct values by default. To allow duplicate values, use the ",a.createElement(t.code,null,"UNION ALL")," operator. The ",a.createElement(t.code,null,"UNION")," operator selects only distinct values by default. To allow duplicate values, use the ",a.createElement(t.code,null,"UNION ALL")," operator."),"\n",a.createElement(t.p,null,"The ",a.createElement(t.code,null,"INTERSECT")," operator is used to combine the result-set of two or more ",a.createElement(t.code,null,"SELECT")," statements, but returns rows only from the first ",a.createElement(t.code,null,"SELECT")," statement that are identical to a row in the second ",a.createElement(t.code,null,"SELECT")," statement. The ",a.createElement(t.code,null,"INTERSECT")," operator selects only distinct values by default. To allow duplicate values, use the ",a.createElement(t.code,null,"INTERSECT ALL")," operator. Similarly, the ",a.createElement(t.code,null,"EXCEPT")," operator is used to combine the result-set of two or more ",a.createElement(t.code,null,"SELECT")," statements, but returns rows only from the first ",a.createElement(t.code,null,"SELECT")," statement that are not identical to a row in the second ",a.createElement(t.code,null,"SELECT")," statement. The ",a.createElement(t.code,null,"EXCEPT")," operator selects only distinct values by default. To allow duplicate values, use the ",a.createElement(t.code,null,"EXCEPT ALL")," operator."),"\n",a.createElement(t.h2,null,"Data storage in Postgres"),"\n",a.createElement(t.p,null,a.createElement(t.code,null,"SHOW data_directory")," - ",a.createElement(t.code,null,"SHOW")," keyword is used to retrieve individual configuration options; in this case it retrieves the location path to the directory where Postgres stores its data. All data for different databases get placed in ",a.createElement(t.code,null,"base")," directory. ",a.createElement(t.code,null,"SELECT oid, datname FROM pg_database;")," provides a list of all databases and their unique identifiers, where ",a.createElement(t.code,null,"oid")," stands for object identifier. Different folders having oid names are present within ",a.createElement(t.code,null,"base")," directory. ",a.createElement(t.code,null,"SELECT * from pg_class;")," provides a list of all objects and their unique identifiers for a database; these unique identifiers are used as file names within these folders. ",a.createElement(t.code,null,"SELECT * FROM pg_stats WHERE tablename = 'users';")," - provides different statistics about a table, including the number of rows and the size of the table."),"\n",a.createElement(t.h3,null,"File terminologies:"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Heap or Heap File")," - file that contains all the data (rows) of a table (not related to heap data structure)"),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Tuple or Item")," - Individual row from the table"),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Block or Page"),' - the heap file is divided into many different "blocks" or "pages". Each page/block stores some number of rows. By default they are 8KB in size. The number of rows that can be stored in a page depends on the size of the rows. The more rows that can fit in a page, the more efficient the database is.'),"\n"),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Full Table Scan")," - scenario when the database engine has to read every row in a table to find the rows that match the query. This is very slow, especially for large tables. In this case Postgres has to load all the rows stored in heap file into memory, and then execute some kind of iteration over these rows to find some matching number of records."),"\n",a.createElement(t.h2,null,"Indexes"),"\n",a.createElement(t.p,null,"Index - a data structure that makes it faster to find rows in a table. It efficiently tells us exactly what block and index a particular record is stored at. Indexes are created on columns. Indexes are stored in a data structure that is optimized for searching, so searching is faster than scanning the whole table. Indexes are not free. They take up space on disk, can be large as they store data from at least one column of the real table, and they slow down writes as they need to be updated for every insert/update/delete operation. Indexes are automatically created for primary keys and unique constraints, which can be viewed using the following query:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-sql"},"SELECT relname, relkind\nFROM pg_class -- this table lists all different objects present in database\nWHERE relkind = 'i';\n")),"\n",a.createElement(t.p,null,"Example to create an index on a column: ",a.createElement(t.code,null,"CREATE INDEX idx_person_name ON person (name);"),". If we don't provide a name, it will be assigned automatically in this format: ",a.createElement(t.code,null,"<table-name>_<column-name>_idx"),". ",a.createElement(t.code,null,"SELECT pg_size_pretty(pg_relation_size('idx_person_name'));")," - provides the size of the index."),"\n",a.createElement(t.p,null,"Keywords used for benchmarking and evaluating queries, but not for real data fetching:"),"\n",a.createElement(t.ol,null,"\n",a.createElement(t.li,null,a.createElement(t.code,null,"EXPLAIN")," - keyword which builds a query plan and displays info about it without actually executing the query."),"\n",a.createElement(t.li,null,a.createElement(t.code,null,"EXPLAIN ANALYZE")," - keyword which provides information about the query plan (strategy that the database engine uses to execute the query), query execution time and query results. It builds a query plan, runs it and then provides information about it."),"\n"),"\n",a.createElement(t.p,null,"Within the results of these keywords, the rows having ",a.createElement(t.code,null,"->")," are called ",a.createElement(t.strong,null,"query nodes"),", which indicate some step where we are trying to access data stored in database, or trying to do some processing. The top row is a query node as well. Order of evaluation: inner most node to the outer most top node. Within each row, the first phrase (example: ",a.createElement(t.code,null,"Hash Join"),") represents how the node is generating data, second phrase (",a.createElement(t.code,null,"cost"),") - amount of processing power required for that step, third phrase (",a.createElement(t.code,null,"rows"),") - estimate of how many rows this step will produce, and last phrase (",a.createElement(t.code,null,"width"),") - estimate of average number of bytes of each row."),"\n",a.createElement(t.h3,null,"Index Types:"),"\n",a.createElement(t.ol,null,"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"B-Tree Index")," - default index type in Postgres. It is a balanced tree data structure. It is sorted by the column that we are indexing. It is very efficient for equality and range queries."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Hash Index")," - it is a hash table data structure. It is very efficient for equality queries, but not for range queries."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"GiST Index")," - it is a generalized search tree data structure used for geometry, full-text search."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"SP-GiST Index")," - space partitioned GiST index is used for clustered data, such as dates - where many rows might have the same value."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"GIN Index")," - it is a generalized inverted index. Used for columns that contain arrays or JSON data."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"BRIN Index")," - it is a block range index. It is very efficient for range queries and specialized for really large datasets."),"\n"),"\n",a.createElement(t.h3,null,"How indexes are created"),"\n",a.createElement(t.p,null,"First, we identify the column that we want to create an index on, for which we want to have a fast lookup. Then we extract only the property that we want to do fast lookups by and the block / index for that property. These values are sorted in a meaningful order (ascending / descending) and organize them into a tree data structure. They are evenly distributed in the leaf nodes of the tree, in a left to right fashion. Helpers are added to root nodes of tree to make it easier to traverse the tree. The tree is then stored on disk."),"\n",a.createElement(t.p,null,"When an SQL query is given to Postgres, parser interprets the meaning of every character in the query first, and builds a ",a.createElement(t.strong,null,"query tree"),", which is essentially a programmatic description of the query to run. Then it is passed to ",a.createElement(t.strong,null,"rewriter"),", which decomposes views into underlying table references, expands wildcards, and so on. Then it is passed to ",a.createElement(t.strong,null,"planner"),", which generates a ",a.createElement(t.strong,null,"query plan"),", which is a strategy that the database engine uses to execute the query in the most efficient way. The query plan is then passed to executor, which executes the query plan and returns the results."),"\n",a.createElement(t.pre,null,a.createElement(t.code,null,"Cost = amount of processing power required for a particular step in the query plan\n\nCost = ((number of pages read sequentially) * seq_page_cost)\n    + ((number of pages read randomly) * random_page_cost)\n    + ((number of rows scanned) * cpu_tuple_cost)\n    + ((number of index entries scanned) * cpu_index_tuple_cost)\n    + ((number of times function / operator evaluated) * cpu_operator_cost)\n")),"\n",a.createElement(t.h2,null,"Common Table Expressions (CTE)"),"\n",a.createElement(t.p,null,"CTE is a temporary result set that is defined within the execution scope of a single SQL statement. It is similar to a derived table in that it is not stored as an object and lasts only for the duration of the query. Unlike a derived table, a CTE can be self-referencing and can be referenced multiple times in the same query. CTEs are defined using ",a.createElement(t.code,null,"WITH")," keyword before the main query."),"\n",a.createElement(t.p,null,"There are two forms of CTEs: ",a.createElement(t.strong,null,"non-recursive")," and ",a.createElement(t.strong,null,"recursive"),'. Non-recursive CTEs are used to define temporary result sets that can be referenced multiple times in a query. Recursive CTEs are used to define temporary result sets that reference themselves. Recursive CTEs are used to solve problems that involve hierarchical data (tree or graph-type data structure), such as organizational charts, bill of materials, and parts explosion, and they must use a "union" keyword unlike simple / non-recursive CTEs.'),"\n",a.createElement(t.p,null,"Example for recursive CTE:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-sql"},"WITH RECURSIVE countdown(val) AS (\n    SELECT 3 as val -- initial or non-recursive query\n    UNION\n    SELECT val - 1 FROM countdown WHERE val > 1 -- recursive query\n)\nSELECT * from countdown;\n\n-- Output: 3, 2, 1\n")),"\n",a.createElement(t.p,null,"Working of recursive CTEs:"),"\n",a.createElement(t.ol,null,"\n",a.createElement(t.li,null,"Postgres defines the results table for the non-recursive query, and working table for the recursive query"),"\n",a.createElement(t.li,null,"It runs the initial non-recursive statement, put the results into the results table and working table"),"\n",a.createElement(t.li,null,"It then runs the recursive statement replacing the table name with a reference to the working table"),"\n",a.createElement(t.li,null,"If recursive statement returns some rows, it appends them to the results table and runs recursion again. If it doesn't return any rows, it stops recursion."),"\n"),"\n",a.createElement(t.h2,null,"Views"),"\n",a.createElement(t.p,null,"A View is a virtual table that consists of a subset of data contained in a table. They are built on top of tables or other views. Views are used for security purposes, to hide the complexity of queries, and to provide a layer of abstraction between the user and the database. Views are created using ",a.createElement(t.code,null,"CREATE VIEW")," statement. Views can be created from a single table, multiple tables, or other views and can be referenced in a place where we would normally reference a table. Views can be created with or without check option. Check option is used to prevent the user from updating the view in a way that would produce rows that are not included in the view."),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Materialized Views")," - they are similar to views, but they store the results of the query in a table-like structure. They are used to improve the performance of queries that involve expensive operations, such as aggregations, joins, etc. They are updated periodically, either manually or automatically. They are created using ",a.createElement(t.code,null,"CREATE MATERIALIZED VIEW")," statement. These contain queries that get executed only at very specific times, but the results are saved and can be referenced without running the query. ",a.createElement(t.code,null,"WITH DATA")," keyword is used to populate the materialized view with data. ",a.createElement(t.code,null,"WITH NO DATA")," keyword is used to create an empty materialized view. ",a.createElement(t.code,null,"REFRESH MATERIALIZED VIEW")," keyword is used to refresh the materialized view."),"\n",a.createElement(t.h2,null,"Transactions"),"\n",a.createElement(t.p,null,"A transaction is a logical unit of work that contains one or more SQL statements. A transaction is an atomic unit. The effects of all the SQL statements in a transaction can be either all committed (applied to the database) or all rolled back (undone from the database). Transactions are created using ",a.createElement(t.code,null,"BEGIN")," keyword. They are committed using ",a.createElement(t.code,null,"COMMIT")," keyword. They are rolled back using ",a.createElement(t.code,null,"ROLLBACK"),' keyword. Transactions are used to ensure data integrity and consistency. They are used to ensure that the database remains in a consistent state, even in the event of power failure, errors, etc. Transactions are used to ensure that all the statements in a transaction are executed successfully, or none of them are executed at all. If any statement in a transaction fails, the entire transaction will be present in an "aborted" state, from which we must rollback. Losing the connection to database will automatically rollback the transaction.'),"\n",a.createElement(t.h3,null,"Schema Migration Files"),"\n",a.createElement(t.p,null,"Schema migration files are used to make changes to the database schema. They are used to create, modify, or delete tables, indexes, views, etc. They are used to make changes to the database schema in a consistent and repeatable way that is safe and reversible, which can be used to keep track of changes over time. A schema migration file can be written in any programming language, and it contains 2 different sections: ",a.createElement(t.code,null,"up")," and ",a.createElement(t.code,null,"down"),". ",a.createElement(t.code,null,"up")," section is used to make changes to the database schema, and ",a.createElement(t.code,null,"down")," section is used to undo the changes made in the ",a.createElement(t.code,null,"up")," section. Schema migration files are executed in the order in which they are created. They are executed in a transaction, which means that if any of the statements in the schema migration file fails, the entire schema migration file will be rolled back."),"\n",a.createElement(t.h3,null,"Multi-Version Concurrency Control (MVCC)"),"\n",a.createElement(t.p,null,"Multi-Version Concurrency Control (MVCC) is a technique used by PostgreSQL to allow multiple transactions to access the same data concurrently without conflicts or delays. It ensures that each transaction has a consistent snapshot of the database and can operate on its own version of the data."),"\n",a.createElement(t.h4,null,"How MVCC Works"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"When a transaction starts, it gets a unique transaction ID (TXID). This ID is later used to keep track of changes made by the transaction."),"\n",a.createElement(t.li,null,"When a transaction reads data, it only sees the data that was committed before the transaction started, as well as any changes it made itself. This ensures that every transaction has a consistent view of the database."),"\n",a.createElement(t.li,null,'Whenever a transaction modifies data (INSERT, UPDATE, or DELETE), PostgreSQL creates a new version of the affected rows and assigns the new version the same TXID as the transaction. These new versions are called "tuples".'),"\n",a.createElement(t.li,null,"Other transactions running at the same time will only see the old versions of the modified rows since their snapshots are still based on the earlier state of the data."),"\n",a.createElement(t.li,null,"When a transaction is committed, PostgreSQL checks for conflicts (such as two transactions trying to modify the same row). If there are no conflicts, the changes are permanently applied to the database, and other transactions can now see the updated data."),"\n"),"\n",a.createElement(t.h3,null,"Write Ahead Log (WAL)"),"\n",a.createElement(t.p,null,"The Write Ahead Log is a technique where any modification to the data is first recorded in the log before being written into the main data storage. The primary purpose of the WAL is to guarantee that the database state is recoverable to a consistent state even in the event of a crash or hardware failure."),"\n",a.createElement(t.h4,null,"How WAL Works"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Write operation:")," When a change is made to the data, PostgreSQL writes the changes to the WAL buffer instead of immediately modifying the disk pages."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Flush operation:")," Once the transaction is committed, the WAL buffer contents are flushed to the on-disk WAL file."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Checkpoint:")," The background writer process writes the 'dirty' pages from the shared buffer to the main data files at specific intervals called 'checkpoints.' It ensures that the actual data files are updated to match the state recorded in the WAL logs."),"\n"),"\n",a.createElement(t.h3,null,"Stages of Query Processing"),"\n",a.createElement(t.p,null,"Query processing in PostgreSQL involves several stages, from parsing SQL queries to producing the final result set:"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Parsing"),": This is the first stage in query processing, where the SQL query is broken down into smaller components and checked for any syntactical errors. The parser creates a parse tree, a data structure representing the different elements of the query."),"\n"),"\n",a.createElement(t.li,null,"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Rewriting"),": At this stage, the parse tree might be modified to apply any necessary optimization or transformation. Examples include removing redundant conditions, simplifying expressions, expanding views, and applying security-related checks."),"\n"),"\n",a.createElement(t.li,null,"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Optimization"),": This stage involves selecting the best execution plan from multiple alternatives. The query optimizer evaluates various strategies based on factors like the availability of indexes, the size of the tables, and the complexity of the conditions in the query. The cost of each plan is estimated, and the one with the lowest cost is chosen as the final plan."),"\n"),"\n",a.createElement(t.li,null,"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Plan Execution"),": The selected execution plan is converted into a series of low-level operations, which are then executed by the executor. The executor retrieves or modifies the data as specified by the plan, executing the required joins, filtering, aggregations, and sorting steps."),"\n"),"\n",a.createElement(t.li,null,"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Returning Results"),": After the successful execution of the plan, the final result set is sent back to the client application. This result set might be in the form of rows of data, a single value, or a confirmation message of completed operations."),"\n"),"\n"),"\n",a.createElement(t.h4,null,"Key Components in Query Processing"),"\n",a.createElement(t.p,null,"There are several key components of PostgreSQL's query processing engine:"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Parser"),": The component responsible for breaking down SQL queries and creating parse trees."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Optimizer"),": The part of the system that evaluates and chooses the optimal execution plan for a given query."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Executor"),": The component that runs the selected execution plan, performing the required operations to retrieve or modify the data."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Statistics Collector"),": This component gathers essential information about the status of the database, including table sizes, distribution of the data, and access frequency. This information is used by the optimizer to make better decisions when choosing execution plans."),"\n"),"\n",a.createElement(t.h3,null,"Row Level Security (RLS)"),"\n",a.createElement(t.p,null,"Row Level Security (RLS) is a feature introduced in PostgreSQL 9.5 that allows us to control access to rows in a table based on a user or role's permissions. This level of granularity in data access provides an extra layer of security for protecting sensitive information from unauthorized access."),"\n",a.createElement(t.p,null,"To enable RLS, we need to set up policies for our table. A policy is a set of rules that define how users can read or modify table rows. First, enable RLS on the table using the ",a.createElement(t.code,null,"ALTER TABLE")," command with the ",a.createElement(t.code,null,"FORCE ROW LEVEL SECURITY")," option:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-sql"},"ALTER TABLE my_table FORCE ROW LEVEL SECURITY;\n")),"\n",a.createElement(t.p,null,"To create a policy, use the ",a.createElement(t.code,null,"CREATE POLICY")," command with a ",a.createElement(t.code,null,"USING")," clause that specifies the conditions for allowing access to a row. Here's an example of a policy that allows users to read rows only if the user's ",a.createElement(t.code,null,"id")," is equal to the ",a.createElement(t.code,null,"user_id")," column in the table:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-sql"},"CREATE POLICY my_policy ON my_table\nFOR SELECT\nUSING (current_user_id() = user_id);\n")),"\n",a.createElement(t.p,null,"We can also create policies for modifying rows by specifying the ",a.createElement(t.code,null,"FOR")," action as ",a.createElement(t.code,null,"INSERT"),", ",a.createElement(t.code,null,"UPDATE"),", or ",a.createElement(t.code,null,"DELETE"),"."),"\n",a.createElement(t.h3,null,"Data Partitioning and Sharding"),"\n",a.createElement(t.p,null,"Data partitioning is a technique that divides a large table into smaller, more manageable pieces called partitions. Each partition is a smaller table that stores a subset of the data, usually based on specific criteria such as ranges, lists, or hashes. PostgreSQL supports different partitioning methods, such as:"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Range Partitioning:")," The data in a range-partitioned table is separated into partitions based on a specified range of values for a given column. For example, orders could be partitioned by date range, with each partition containing orders within a specific date interval."),"\n"),"\n",a.createElement(t.li,null,"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"List Partitioning:")," The data in a list-partitioned table is separated into partitions based on specified discrete sets of values for a given column. For example, customers could be partitioned by their country, with each partition storing customers from a specific country."),"\n"),"\n",a.createElement(t.li,null,"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Hash Partitioning:")," The data in a hash-partitioned table is divided into partitions using a hash function applied to one or more columns. This method distributes data uniformly across all partitions, which helps in load balancing and parallel query processing. For example, products could be hash partitioned based on the product ID."),"\n"),"\n"),"\n",a.createElement(t.p,null,"Sharding is a technique that splits a large dataset across multiple database instances or servers, called shards. Each shard is an independent and self-contained unit that holds a portion of the overall data, and shards can be distributed across different geographical locations or infrastructures. A horizontal fragment or shard of a relation is a subset of the tuples in that relation. The tuples that belong to the horizontal fragment can be specified by a condition on one or more attributes of the relation, or by some other mechanism. Often, only a single attribute in involved in the condition."),"\n",a.createElement(t.p,null,"In PostgreSQL environment, sharding can be achieved in different ways:"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Sharding at the application level:")," The application defines the logic to decide which shard will store a specific data record. The application communicates directly with each shard for querying or modifying the data."),"\n"),"\n",a.createElement(t.li,null,"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Sharding using foreign data wrappers:")," PostgreSQL provides a feature called foreign data wrappers (FDW) that allows a PostgreSQL server to access data stored in remote servers, treating them as local tables. By using this technique, the data can be sharded across multiple remote servers, and the local PostgreSQL instance acts as a coordinator for accessing these shards."),"\n"),"\n",a.createElement(t.li,null,"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Sharding using 3rd-party tools:")," Several 3rd-party tools, such as Pgpool-II, Citus, and PLProxy, can be used for sharding purpose. These tools handle connection pooling, load balancing, and data distribution across multiple PostgreSQL instances. The choice of tools depends on the requirements, complexity, and the desired level of control over the sharding logic."),"\n"),"\n"),"\n",a.createElement(t.h3,null,"CAP Theorem"),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Consistency")," means that the nodes will have the same copies of a replicated data item visible for various transactions. ",a.createElement(t.strong,null,"Availability")," means that each read or write request for a data item will either by processed successfully or will receive a message that the operation cannot be completed. ",a.createElement(t.strong,null,"Partition Tolerance")," means that the system can continue operating if the network connecting the nodes has a fault that results in two or more partitions, where the nodes in each partition can only communicate among each other. The ",a.createElement(t.strong,null,"CAP Theorem")," states that it is not possible to guarantee all three of the desirable properties - consistency, availability, and partition tolerance - at the same time in a distributed system with data replication. If this is the case, then the distributed system designer would have to choose two properties out of the three to guarantee."),"\n",a.createElement(t.h3,null,"Algorithms for SELECT Operation"),"\n",a.createElement(t.p,null,"A number of search algorithms are possible for selecting records from a file, which are known as ",a.createElement(t.strong,null,"file scans"),", because they scan the records of a file to search for and retrieve records that satisfy a selection condition. If the search algorithms involves the use of an index, the index search is called an ",a.createElement(t.strong,null,"index scan"),". Different search algorithms:"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"S1 - Linear search (brute force algorithm)"),"\n",a.createElement(t.li,null,"S2 - Binary search (requires sorted data)"),"\n",a.createElement(t.li,null,"S3a - Using a primary index, S3b - Using a hash key"),"\n",a.createElement(t.li,null,"S4 - Using a primary index to retrieve multiple records"),"\n",a.createElement(t.li,null,"S5 - Using a clustering index to retrieve multiple records"),"\n",a.createElement(t.li,null,"S6 - Using a secondary (B+ tree) index on an equality comparison"),"\n",a.createElement(t.li,null,"S7a - Using a bitmap index, S7b - Using a functional index"),"\n",a.createElement(t.li,null,"S8 - Conjunctive selection using an individual index"),"\n",a.createElement(t.li,null,"S9 - Conjunctive selection using a composite index"),"\n",a.createElement(t.li,null,"S10 - Conjunctive selection by intersection of record pointers"),"\n"),"\n",a.createElement(t.h2,null,"Credits & Attributions:"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,a.createElement(t.a,{href:"https://www.postgresql.org/docs/"},"Official Postgres Documentation")),"\n",a.createElement(t.li,null,a.createElement(t.a,{href:"https://hasura.io/learn/database/postgresql/core-concepts/"},"Core Postgres Concepts")),"\n",a.createElement(t.li,null,a.createElement(t.a,{href:"https://www.postgresqltutorial.com/"},"PostgreSQL Tutorial")),"\n"))}var s=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,l.RP)(),e.components);return t?a.createElement(t,e,a.createElement(r,e)):r(e)},o=n(1173);function i(e){return a.createElement(o.A,e,a.createElement(s,e))}o.A}}]);
//# sourceMappingURL=component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx-content-file-path-content-posts-database-concepts-index-mdx-397552b8c46ab0d6ce73.js.map