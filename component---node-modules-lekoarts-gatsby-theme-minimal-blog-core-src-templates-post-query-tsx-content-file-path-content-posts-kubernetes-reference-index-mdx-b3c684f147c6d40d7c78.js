"use strict";(self.webpackChunkminimal_blog=self.webpackChunkminimal_blog||[]).push([[803],{1173:function(e,t,n){n.d(t,{p:function(){return p},A:function(){return h}});var a=n(454),l=n(6540),s=n(557),o=n(6835),r=n(3328),i=n(7715),c=n(7169);var u=e=>{let{post:t}=e;return null};const d=["16px","8px","4px"].map(e=>"rgba(0, 0, 0, 0.1) 0px "+e+" "+e+" 0px");var m=e=>{let{data:{post:t},children:n}=e;return(0,s.Y)(r.A,null,(0,s.Y)(o.DZ,{as:"h1",variant:"styles.h1"},t.title),(0,s.Y)("p",{sx:{color:"secondary",mt:3,a:{color:"secondary"},fontSize:[1,1,2]}},(0,s.Y)("time",null,t.date),t.tags&&(0,s.Y)(l.Fragment,null," — ",(0,s.Y)(i.A,{tags:t.tags})),t.timeToRead&&" — ",t.timeToRead&&(0,s.Y)("span",null,t.timeToRead," min read")),(0,s.Y)("section",{sx:{my:5,".gatsby-resp-image-wrapper":{my:[4,4,5],borderRadius:"4px",boxShadow:d.join(", "),".gatsby-resp-image-image":{borderRadius:"4px"}},variant:"layout.content"}},n),(0,s.Y)(u,{post:t}))};const p=e=>{var t,n,a;let{data:{post:l}}=e;return(0,s.Y)(c.A,{title:l.title,description:l.description?l.description:l.excerpt,image:l.banner?null===(t=l.banner)||void 0===t||null===(n=t.childImageSharp)||void 0===n||null===(a=n.resize)||void 0===a?void 0:a.src:void 0,pathname:l.slug,canonicalUrl:l.canonicalUrl})};function h(e){let t=Object.assign({},((0,a.A)(e),e));return l.createElement(m,t)}},7684:function(e,t,n){n.r(t),n.d(t,{Head:function(){return r.p},default:function(){return i}});var a=n(6540),l=n(8453);function s(e){const t=Object.assign({h2:"h2",p:"p",strong:"strong",span:"span",h3:"h3",ul:"ul",li:"li",code:"code",pre:"pre",hr:"hr",ol:"ol",h4:"h4",a:"a",blockquote:"blockquote"},(0,l.RP)(),e.components);return a.createElement(a.Fragment,null,a.createElement(t.h2,null,"Introduction"),"\n",a.createElement(t.p,null,"Kubernetes is a portable, extensible, open source platform for managing containerized workloads and services, that facilitates both declarative configuration and automation. It has a large, rapidly growing ecosystem. Kubernetes services, support, and tools are widely available. Kubernetes is a system for running many different containers over multiple different machines. It is used when we need to run many different containers with different images."),"\n",a.createElement(t.p,null,"We can work with Kubernetes in development environment using ",a.createElement(t.strong,null,"minikube"),", and in production environment using AWS EKS, GKE or other managed solutions. ",a.createElement(t.strong,null,"minikube")," is local Kubernetes, focusing on making it easy to learn and develop for Kubernetes. It is a command-line tool which sets up a tiny Kubernetes cluster. ",a.createElement(t.strong,null,"kubectl")," is used to interact with a Kubernetes cluster in general and manage what all the different nodes are doing and what different containers they are running. Minikube is used to create and run a Kubernetes cluster in our local machine."),"\n",a.createElement(t.h2,null,"Components of Kubernetes"),"\n",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 46.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACvUlEQVR42jWSXUxScRjGT7W1ddddN9104W1zs9t0fahoFpqfR74OnNP5+J9z/oigpjJ1JJKa4hRQ1liM0JGi0vTCuRVrCeJXfoCRzdEUL3Jtqbk2UDc6FT7be/t7n+d5X4TgGm/j2peQhMZqmtWVKmE/rlR3ySkWlrS1tVUODg7iFosFs1qtSkNr42MpZ8Yw2K3gAVEGIcxA/uui2ryZ/WLydxaiJNgi7cBWtKHXP0xW3HxY07M8q7dvLqCohGAYhuZ5NQMAYADPMwwlxfN0G5H8+q0tyJKkAMwSYBeEuUYYQ/hz72k+wnDaB7DOpAHadkg/UchYWEdzDX1aBtbjDElKURStkslk1QqFQoKiFVXlZDsswbuhXJCwKDPt8CrVsSDpHT+9i9Dqp49YliV4HsgYUi4FXSuzWtO0Ha0ok+v1LXVOp9Nis9k6heiGYbe7f9BqbvS4HUaX02luamq9lQZewkzRhxrHrxyE4pvEHKWUszRWTRFSucbgNtU+e2MWFRZKfb5J+8+Dw9T29vZeNBoNHx0dpdbW1oI7u/GTWOxb0uFw5Jx3qLPFS40jh7kISaryOIPPxrWN9lAqVAIMb6265l5dZTVWOT4+agt8TqQCK7F4cGkj7A+fpdZXQ4GZ0H7yw3I8MTFsPQdeqR34Ut7lPb6PkACIWL3bxLU4Wzm8rLzR/jWk7//oEosLin0+75B/I5maW47tBZci4dnVs9Tm+lJgOrB/8m4hnpz2DmWngZdrLDvijpFDkRBZXwYAR2EYTlVJ8XqViqABbOJQOamc8I4NzW0mUvOf/gEjfx2G1xaDM/PfT/yLuycet/VOGnidMLzP6ptKZCBArc4ULlsEeJ2IptUFNKcu4HmNiKKo3E6jsdg3MUa7XK8wp8MhnZoYZYSfRCfHPYRn+DXV3Nx847zDSGRDcnD8494fgt1hsji9FBIAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="Kubernetes Components"\n        title=""\n        src="/ruminations/static/317c50cc08d4e77d02b005c4840fb7a6/7d769/components-of-kubernetes.png"\n        srcset="/ruminations/static/317c50cc08d4e77d02b005c4840fb7a6/5243c/components-of-kubernetes.png 240w,\n/ruminations/static/317c50cc08d4e77d02b005c4840fb7a6/ab158/components-of-kubernetes.png 480w,\n/ruminations/static/317c50cc08d4e77d02b005c4840fb7a6/7d769/components-of-kubernetes.png 960w,\n/ruminations/static/317c50cc08d4e77d02b005c4840fb7a6/4d9c5/components-of-kubernetes.png 1252w"\n        sizes="(max-width: 960px) 100vw, 960px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>'}}),"\n",a.createElement(t.p,null,"A cluster in the world of Kubernetes is the assembly of something called a ",a.createElement(t.strong,null,"master"),", and one or more ",a.createElement(t.strong,null,"nodes"),". A ",a.createElement(t.strong,null,"node")," is a virtual machine or a physical computer which is going to be used to run some number of different containers. Each node can run different set of containers. All the different nodes created are managed by the master. The master has a set of different programs running on it that control what each of these different nodes is running at any given time. Developers interact with a Kubernetes cluster by reaching out to this master and provide instructions to it (example: to run certain number of containers using a specific image), which are then relayed by master to all the nodes. There is a load balancer outside the cluster which takes some amount of outside traffic in the form of network requests and relay all those requests into each of these different nodes."),"\n",a.createElement(t.p,null,"The worker node(s) host the Pods that are the components of the application workload. The control plane manages the worker nodes and the Pods in the cluster. In production environments, the control plane usually runs across multiple computers and a cluster usually runs multiple nodes, providing fault-tolerance and high availability."),"\n",a.createElement(t.h3,null,"Control Plane Components"),"\n",a.createElement(t.p,null,"The control plane's components make global decisions about the cluster (for example, scheduling), as well as detecting and responding to cluster events (for example, starting up a new pod when a deployment's replicas field is unsatisfied)."),"\n",a.createElement(t.p,null,"Control plane components can be run on any machine in the cluster. However, for simplicity, set up scripts typically start all control plane components on the same machine, and do not run user containers on this machine."),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"kube-apiserver")," - The API server is a component of the Kubernetes control plane that exposes the Kubernetes API. The API server is the front end for the Kubernetes control plane. The main implementation of a Kubernetes API server is kube-apiserver. kube-apiserver is designed to scale horizontally—that is, it scales by deploying more instances. We can run several instances of kube-apiserver and balance traffic between those instances."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"etcd")," - Consistent and highly-available key value store used as Kubernetes' backing store for all cluster data"),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"kube-scheduler")," - Control plane component that watches for newly created Pods with no assigned node, and selects a node for them to run on"),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"kube-controller-manager")," - Control plane component that runs controller processes. Logically, each controller is a separate process, but to reduce complexity, they are all compiled into a single binary and run in a single process."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"cloud-controller-manager")," - A Kubernetes control plane component that embeds cloud-specific control logic. The cloud controller manager lets us link our cluster into our cloud provider's API, and separates out the components that interact with that cloud platform from components that only interact with our cluster. The cloud-controller-manager only runs controllers that are specific to our cloud provider. It combines several logically independent control loops into a single binary that we run as a single process. We can scale horizontally (run more than one copy) to improve performance or to help tolerate failures."),"\n"),"\n",a.createElement(t.h3,null,"Node Components"),"\n",a.createElement(t.p,null,"Node components run on every node, maintaining running pods and providing the Kubernetes runtime environment."),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"kubelet")," - An agent that runs on each node in the cluster. It makes sure that containers are running in a Pod. The kubelet takes a set of PodSpecs that are provided through various mechanisms and ensures that the containers described in those PodSpecs are running and healthy. The kubelet doesn't manage containers which were not created by Kubernetes."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"kube-proxy")," - kube-proxy is a network proxy that runs on each node in the cluster, implementing part of the Kubernetes Service concept. kube-proxy maintains network rules on nodes. These network rules allow network communication to our Pods from network sessions inside or outside of our cluster."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"container runtime")," - The container runtime is the software that is responsible for running containers. Kubernetes supports several container runtimes: Docker, containerd, CRI-O, and any implementation of the Kubernetes CRI (Container Runtime Interface)."),"\n"),"\n",a.createElement(t.h2,null,"Basic Commands"),"\n",a.createElement(t.h3,null,"minikube commands"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,a.createElement(t.code,null,"minikube status")," - provides information on minikube and kubectl running status"),"\n",a.createElement(t.li,null,a.createElement(t.code,null,"minikube dashboard")," - dashboard running on port 30000 which provides information on everything inside the Kubernetes cluster. Any edits made to any objects in the dashboard do not persist to the config files, hence it is discouraged."),"\n",a.createElement(t.li,null,a.createElement(t.code,null,"minikube cp <source node name>:<source file path> <target node name>:<target file absolute path> [flags]")," - copy the specified file into minikube, it will be saved at path in your minikube. Default target node controlplane and If is omitted, It will trying to copy from host."),"\n",a.createElement(t.li,null,a.createElement(t.code,null,"minikube delete")," - deletes a local Kubernetes cluster. This command deletes the VM, and removes all associated files."),"\n",a.createElement(t.li,null,a.createElement(t.code,null,"minikube ip")," - retrieves the IP address of the specified node, and writes it to STDOUT. In local environment, the Kubernetes Node VM created by Minikube has its own IP address, which should be used to access any pod / service running in Minikube, not the localhost. Use ",a.createElement(t.code,null,"minikube ip")," command to get this IP address."),"\n",a.createElement(t.li,null,a.createElement(t.code,null,"minikube logs")," - Gets the logs of the running instance, used for debugging minikube, not user code."),"\n"),"\n",a.createElement(t.h3,null,"kubectl commands"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,a.createElement(t.code,null,"kubectl cluster-info")," - provides information on master, KubeDNS status"),"\n",a.createElement(t.li,null,a.createElement(t.code,null,"kubectl apply -f <filename>")," - it is used to provide a config file to kubectl. ",a.createElement(t.code,null,"apply")," command changes the current configuration of our cluster with kubectl. It is also possible to run this command on all YAML files in a directory by using ",a.createElement(t.code,null,"kubectl apply -f <folder-name>"),"."),"\n",a.createElement(t.li,null,a.createElement(t.code,null,"kubectl get pods")," - prints the status of all running pods. ",a.createElement(t.code,null,"get pods")," - specifies that information needs to be retrieved about a running object, and the object type is pods in this case. In the output, under ",a.createElement(t.code,null,"READY")," section, 1/1 indicates that there is one copy of the object running, and desired number of objects running is 1. ",a.createElement(t.code,null,"-o wide")," arguments for ",a.createElement(t.code,null,"get pods")," command provides more information on pods, like host IP and node name.","\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,a.createElement(t.code,null,"kubectl get services")," prints the status of all running services. It doesn't display the ",a.createElement(t.code,null,"targetPort")," of services."),"\n",a.createElement(t.li,null,a.createElement(t.code,null,"kubectl get deployments")," prints the status of all deployments, in the output of which ",a.createElement(t.code,null,"DESIRED")," and ",a.createElement(t.code,null,"CURRENT")," represents number of desired objects and number of current objects running respectively, ",a.createElement(t.code,null,"UP-TO-DATE")," represents number of objects up-to-date with given config file and ",a.createElement(t.code,null,"AVAILABLE")," represents number of objects that are ready to receive traffic."),"\n",a.createElement(t.li,null,a.createElement(t.code,null,"kubectl get pv")," lists out all persistent volumes attached to the Pods"),"\n",a.createElement(t.li,null,a.createElement(t.code,null,"kubectl get pvc")," lists out all persistent volume claims configured."),"\n"),"\n"),"\n",a.createElement(t.li,null,a.createElement(t.code,null,"kubectl describe <object-type> <object-name>")," - gets detailed information about an object inside a Kubernetes cluster. If ",a.createElement(t.code,null,"<object-name>")," is omitted, then it describes all objects having ",a.createElement(t.code,null,"<object-type>"),". Example: ",a.createElement(t.code,null,"kubectl describe pod client-pod1"),"."),"\n",a.createElement(t.li,null,a.createElement(t.code,null,"kubectl delete -f <config-file>")," - removes a running object specified by config file that created the object. Deleting objects is an imperative approach in Kubernetes (not declarative)."),"\n",a.createElement(t.li,null,a.createElement(t.code,null,"kubectl set image <object-type>/<object-name> <container-name>=<new-image-to-use>")," - changes a property of an object inside the cluster by specifying the object name, property and the new value that the property should have."),"\n",a.createElement(t.li,null,a.createElement(t.code,null,"kubectl delete <object-type> <object-name>")," - deletes an object. Example: ",a.createElement(t.code,null,"kubectl delete deployment client-deployment")," - deletes a deployment."),"\n",a.createElement(t.li,null,a.createElement(t.code,null,"kubectl logs <pod-name>")," - gets all logs for a pod, if they exist."),"\n",a.createElement(t.li,null,a.createElement(t.code,null,"kubetl get storageclass")," - lists out all different storage options available in the cluster that Kubernetes has for creating a Persistent Volume. ",a.createElement(t.code,null,"standard")," is the default option."),"\n"),"\n",a.createElement(t.h2,null,"Kubernetes Objects"),"\n",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 71.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAABYlAAAWJQFJUiTwAAACNklEQVR42m1S2XKjMBD0///U7ktqk0o5G5uAzWEJxCEugcQlrsTbmGzVPuw8CAamZ3pafViWJUkSx3F830/TdJ5npHEc53l2v9+XeWGMBUGAX0jXdf38Jw6o7rouy7I8z/u+n6aJEmo79sUiJZl0NwcBJYSg9X/AWuumaQDDiS5IlVIpT6TSltN2w8oScTQCNAUYgK9HfIP3HFTRP4oibFEUhSjLQtReJOt+4WL0eSulFEJgBmpAE5PQ6xscx6FhnG+ei091LbffSs1fPc3NUFyntf1cMQ2sF8s0X19fOec7+AuPQs7vrqxAXJeyy2QrsEQY0TBlra76qdFjP05aT4tLk4CFo9YbGMuMuveY+HUuaFqy/Ez4MRGBd/Ov9hXiMZY44dGkP/z83Y2aS9BCtWWB0MthGAbojNvBmn3fYQW0/PDyk3nzHMu03eD4U8vqIfWSch5uwbA5VDjs6t0fsXxOoonTOju79OmURMXYR1d2eiKcsNQVTbj+DeiKc6ON4ZBRD6PqCjd6M8iLaCiL+cWhxL6oRmXKvrLfUXmZ5nF5MAYSIw+4VfDgj6hERXljM7ldScgI8TxCm0bVSpu+LKqO83gPzNvAO2e0EKJSjeTxEAZoP5dliaI0zTZBh9n3dF1rIWCCYkduJgEBgHGxlmWdPz4cI0m8sihygOFnlMZxRG/B7cSpn7quaxhGXde72zaT4A3GhIHhs6aVp/P78/PLXoHAOse3o0fcfuiwIMraFg5SWus/9r0KUbaga9IAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="Kubernetes API Structure"\n        title=""\n        src="/ruminations/static/633fc9fcb059a94e0b299692f3d0c949/7d769/kube-api-structure.png"\n        srcset="/ruminations/static/633fc9fcb059a94e0b299692f3d0c949/5243c/kube-api-structure.png 240w,\n/ruminations/static/633fc9fcb059a94e0b299692f3d0c949/ab158/kube-api-structure.png 480w,\n/ruminations/static/633fc9fcb059a94e0b299692f3d0c949/7d769/kube-api-structure.png 960w,\n/ruminations/static/633fc9fcb059a94e0b299692f3d0c949/87339/kube-api-structure.png 1440w,\n/ruminations/static/633fc9fcb059a94e0b299692f3d0c949/88b03/kube-api-structure.png 1920w,\n/ruminations/static/633fc9fcb059a94e0b299692f3d0c949/9d489/kube-api-structure.png 3000w"\n        sizes="(max-width: 960px) 100vw, 960px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>'}}),"\n",a.createElement(t.p,null,"Kubernetes objects are persistent entities in the Kubernetes system. Kubernetes uses these entities to represent the state of our cluster. Specifically, they can describe:"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"What containerized applications are running (and on which nodes)"),"\n",a.createElement(t.li,null,"The resources available to those applications"),"\n",a.createElement(t.li,null,"The policies around how those applications behave, such as restart policies, upgrades, and fault-tolerance"),"\n",a.createElement(t.li,null,"A Kubernetes object is a \"record of intent\" -- once we create the object, the Kubernetes system will constantly work to ensure that object exists. By creating an object, we're effectively telling the Kubernetes system what we want our cluster's workload to look like; this is our cluster's desired state."),"\n"),"\n",a.createElement(t.p,null,"Almost every Kubernetes object includes two nested object fields that govern the object's configuration: the object ",a.createElement(t.code,null,"spec`` and the object "),"status`. For objects that have a spec, we have to set this when we create the object, providing a description of the characteristics we want the resource to have: its desired state."),"\n",a.createElement(t.p,null,"The status describes the current state of the object, supplied and updated by the Kubernetes system and its components. The Kubernetes control plane continually and actively manages every object's actual state to match the desired state we supplied."),"\n",a.createElement(t.p,null,"Kubernetes expects all images to already be built, which are ready for deployment on to Kubernetes cluster. We have multiple configuration files in Kubernetes, and each of these config files are used to create a different object (which isn't necessarily a container) using kubectl. We have to manually set up all networking in Kubernetes."),"\n",a.createElement(t.p,null,"Example Object Types include: StatefulSet, ReplicaController, Pod, Service. Objects are essentially things that are going to be created inside Kubernetes cluster to get our application running as expected, and they serve different purposes - running a container (Pod), monitoring a container, setting up networking (Service) etc. The ",a.createElement(t.code,null,"kind")," keyword in yaml files represents the type of object that should be created."),"\n",a.createElement(t.p,null,"When we specify the ",a.createElement(t.code,null,"apiVersion"),", it essentially scopes / limits the types of objects that we can specify that we want to create within any configuration file. Each API version defines a different set of 'objects' we can use."),"\n",a.createElement(t.p,null,"A ",a.createElement(t.strong,null,"Pod")," is a grouping of containers (one or more) with a very common purpose, which runs these closely related containers. It is the smallest thing we can deploy within a Kubernetes cluster, to run a single container. Always group containers in a pod that have a very tightly coupled relationship, and must be running together. ",a.createElement(t.code,null,"metadata")," is used in kubectl to provide additional information about the object which can be useful in logging. Pod runs a single set of containers, used for development purposes, but not in production. Every single Pod gets an IP address assigned to it that is internal to the VM."),"\n",a.createElement(t.p,null,"A ",a.createElement(t.strong,null,"Service")," sets up networking in a Kubernetes cluster. There are 4 commonly used subtypes among Services: ClusterIP, NodePort, LoadBalancer, Ingress. The purpose of a NodePort service is to expose a container to the outside world, and it is only good for development work."),"\n",a.createElement(t.p,null,"A ",a.createElement(t.strong,null,"Deployment")," is a Kubernetes object which maintains a set of identical pods, ensuring that they have the correct config and that the right number exists. Deployment object is also referred to as a type of contoller. A ",a.createElement(t.strong,null,"controller")," is any type of object that constantly works to make some desired state a reality inside the cluster. Deployment runs a set of identical pods (one or more) and monitors the state of each pod, updating as necessary. It is frequently used in both development and production environments. A Deployment consists of a pod template, which is essentially a configuration block which describes pods created by the deployment (ReplicaSets are legacy variant of Deployments)."),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"ClusterIP")," service exposes a set of pods to other objects in the Kubernetes cluster (but not to outside world), whereas ",a.createElement(t.strong,null,"NodePort")," exposes a set of pods to the outside world. ClusterIP follows the same port nomenclature as NodePort service."),"\n",a.createElement(t.p,null,"A ",a.createElement(t.strong,null,"Namespace")," is used to isolate the different resources that are created inside Kubernetes cluster. A ",a.createElement(t.strong,null,"ConfigMap")," is an object that holds some amount of configuration that can be used throughout the cluster. ",a.createElement(t.code,null,"kube-system")," namespace (which is created automatically) contains some objects that make the entire cluster work as expected at an administration level."),"\n",a.createElement(t.p,null,"Let's consider a container having exposed port 3000 via ",a.createElement(t.code,null,"containerPort")," option, running in a Pod, which is enclosed and running within a Kubernetes Node (e.g., VM created by MiniKube). Every single node or every single member of a Kubernetes cluster that we create has a program on it called ",a.createElement(t.code,null,"kube-proxy"),", which is essentially the one single-window to the outside world. Any requests coming in flow through ",a.createElement(t.code,null,"kube-proxy"),", which inspects the request and decides how to route it to different services or different pods that are created inside the Node. The NodePort service forwards the incoming request from ",a.createElement(t.code,null,"kube-proxy")," to the exposed port on the running container defined inside the Pod."),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Label Selector System")," is used in Kubernetes to specify which Pod should the Service route the incoming requests. In the provided example configs, the ",a.createElement(t.code,null,"component: web")," key-value pair under ",a.createElement(t.code,null,"labels")," allows the container to link to Service with ",a.createElement(t.code,null,"component: web")," key-value pair in its configuration. The key-value pair can be anything, as long it is the same for both Pod and Service. This system is also used by Deployment to communicate to master to gain control over the objects created by master having the specified key-value pairs. Service watches every pod that matches its selector and then automatically route traffic to it, irrespective of pod deletion and re-creation (resulting in change of Pod's internal IP address)."),"\n",a.createElement(t.p,null,"Master contains 4 programs that control the entire Kubernetes cluster. One of them, ",a.createElement(t.strong,null,"Kube API server")," is responsible for monitoring the current status of all the different nodes inside the cluster and ensure that they are running. It takes in YAML deployment files as input and maintains a table of all objects that are currently running and the objects that need to be run along with the required number of copies of objects. Each node has a copy of Docker running in it, which pulls image from provided docker registry and runs the containers as per the requirements. The ",a.createElement(t.strong,null,"Kube API server")," automatically instructs nodes to restart crashed containers and ensures that the desired number of objects are running."),"\n",a.createElement(t.p,null,"Each node can run a dissimilar set of containers, depending on the requirements (number of desired objects). To deploy something, we update the desired state of the master with a config file and the master works constantly to fulfill this state. But ",a.createElement(t.code,null,"kubectl apply -f <filename>")," can only be used to update certain fields like image, but not container ports or other fields."),"\n",a.createElement(t.h2,null,"Sample Configurations"),"\n",a.createElement(t.p,null,"Sample container config (Pod)"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-yaml"},"apiVersion: v1\nkind: Pod\nmetadata:\n  name: client-pod\n  labels:\n    component: web\nspec:\n  containers:\n    - name: client\n      image: someuser/multi-worker # assuming image is on DockerHub\n      ports:\n        - containerPort: 3000\n")),"\n",a.createElement(t.hr),"\n",a.createElement(t.p,null,"Sample networking config (NodePort)"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-yaml"},"apiVersion: v1\nkind: Service\nmetadata:\n  name: client-node-port\nspec:\n  type: NodePort\n  ports: # describes all the collection of ports that need to be opened up or mapped on the target objects\n    - port: 3050 # port that another Pod / container could connect in order to get access to target container\n      targetPort: 3000 # port of target container that is exposed\n      nodePort: 31515 # port truly exposed to outside world, which we can use to connect to target container (always ranges between 30000 - 32767, random number in this range is assigned as defaulf if this is not specified)\n  selector:\n    component: web # Service looks for this key-value pair among all objects metadata, and forwards the request to that object for the above specified ports.\n")),"\n",a.createElement(t.hr),"\n",a.createElement(t.p,null,"Sample deployment config"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-yaml"},'apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: client-deployment\nspec:\n  replicas: 1 # number of different pods the deployment is supposed to create / maintain\n  selector: # similar to "selector" in service configuration\n    matchLabels: # Deployment gains control over objects having these labels\n      component: web\n  template: # it specifies the configuration used for every single pod that is created / maintained by this deployment\n    metadata:\n      labels:\n        component: web\n    spec:\n      containers:\n        - name: client\n          image: someuser/multi-client\n          ports:\n            - containerPort: 3000\n')),"\n",a.createElement(t.hr),"\n",a.createElement(t.p,null,"Sample ClusterIP service config"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-yaml"},"apiVersion: v1\nkind: Service\nmetadata:\n  name: client-cluster-ip-service\nspec:\n  type: ClusterIP\n  selector:\n    component: web\n  ports:\n    - port: 3000 # other objects in the cluster access the service using this port\n      targetPort: 3000 # port on the target pod that the service is providing access to\n")),"\n",a.createElement(t.h2,null,"Kubernetes Deployment Methods"),"\n",a.createElement(t.p,null,"2 ways of deployments (Kubernetes supports both of them):"),"\n",a.createElement(t.ol,null,"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Imperative deployments"),' - "Do exactly these steps to arrive at this container setup". Implicitly specify each step that should be taken for the deployment. Example: running kubectl commands to update some nodes to run the latest version of an image'),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Declarative deployments"),' - "Our container setup should look like this, make it happen". Specify requirements at a high level and let the service handle the rest. Example: updating kubernetes config files to tell master to handle updation of some nodes to a new version of an image.'),"\n"),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Kubernetes Github repo issue #33664")," - issue with making deployment file to force deployment to update all pods without changing image name or image tag. The problem with Deployment is there is no indicator for container image version that mentions that pods need to be deployed again where the same image has changed. kubectl apply will reject the config file if there are no changes (even if the image has been changed in the container registry). There are 3 ways to solve this issue:"),"\n",a.createElement(t.ol,null,"\n",a.createElement(t.li,null,"Manually delete pods to get the Deployment to recreate them with the latest version (not recommended, as it could lead to deletion of wrong pods in production)"),"\n",a.createElement(t.li,null,"Tag built images with a real version number and specify that version in the config file, which just adds an extra step in the production deployment process"),"\n",a.createElement(t.li,null,"Use an imperative command to update the image version the Deployment should use (most reasonable of the three). Example: tag the image with a version number (and push it to container registry), then run ",a.createElement(t.code,null,"kubectl set image <object-type>/<object-name> <container-name>=<new-image-to-use>"),' which changes the "image" property of an object (like Deployment) by specifying the container name that should be updated along with the full name of new image to be used for the container. Here, this command would be: ',a.createElement(t.code,null,"kubectl set image deployment/client-deployment client=someuser/multi-client:v5"),"."),"\n"),"\n",a.createElement(t.p,null,"When minikube is installed, there are 2 Docker client-server pairs running in the local environment: one for Docker (if it was installed prior), and the other pair created by minikube within VM (Node). If we want to configure our local Docker CLI client to communicate with Docker servier within minikube VM, use ",a.createElement(t.code,null,"eval $(minikube docker-env)")," which temporarily configures the Docker CLI to connect to Docker server inside Kubernetes Node temporarily (until the end of terminal session). This can be used for debugging, manually killing containers inside Kubernetes Node and also delete cached images in the Node."),"\n",a.createElement(t.p,null,"It is possible to combine multiple config files into a single file, and there is no limit to the number of config pieces that can be put into a file. All configs within a file are separated by ",a.createElement(t.code,null,"---")," which indicates the separator. Recommended approach is to keep every config in a separate file to identify objects easily."),"\n",a.createElement(t.h2,null,"Persistent Volume Claim (PVC)"),"\n",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 833px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 53.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAABJ0AAASdAHeZh94AAAB/ElEQVR42j1Sy27TQBTND/cH2HXVLhBlWxArhETVBRRFhYos6CMkhMR14sSJ09aPOFXid14znvFjzHEMXMmj8b1z7uucmqZpg8FgOp3meV7sLQgCRVHgV1XVMAwhBJxJkozH436/PxwOcS6XSzhrvV6v2WxalpXvLcuyKIra7bYsy51OZzabVRkRkmWp35e1iTYajTzPK8Hr9dr3fSRGgTRNS3yep3vDJReiSor6O8IJTTjnKIBoCcaHAMCExJ4bxDFDGL+cMRqGNIoYY3FMg3knmF3zlYLMxT+rCb4SGReFaNTlV4cX8i8T3qwo1rp+f3w8eH1C/Cjlnisf3X892JpnPMnRjCAOULXbO8l+dgCwzeD6amQ+lsMkaGyz0b5cWI0G2xFKQhqq4UIuEh9AGvOzy96zs64dvZd/qwDn0Sp60h883+V7Qwo0jIkopZwRwxWffpI7lWEkQvnbb3PLjTGzqJbcarVOT9/c3NxGUcgZDzZuvffxu/LZDZws4R3Ne9e4/PBDClYMlUQ18//psX0QO5/P06xciR3oh+cHL+svnHCBx/pidSU1W5OHmEEO4u/CwCp4gypwgraqCzCx3W0tR585JiG06t9zQ8u0LdO0bRu6wLOSZ0mSoCTTxDtS6QwZu92uoZtPj7quG2mawOm6rjJUJpMJpFYp7A/Z71e1znPRkgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="Persistent Volume Claim"\n        title=""\n        src="/ruminations/static/eaab8362c1f7de0601275b2453515a17/1591e/pvc.png"\n        srcset="/ruminations/static/eaab8362c1f7de0601275b2453515a17/5243c/pvc.png 240w,\n/ruminations/static/eaab8362c1f7de0601275b2453515a17/ab158/pvc.png 480w,\n/ruminations/static/eaab8362c1f7de0601275b2453515a17/1591e/pvc.png 833w"\n        sizes="(max-width: 833px) 100vw, 833px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>'}}),"\n",a.createElement(t.p,null,"When Postgres is deployed as a container, if the container crashes for any reason and is restarted, all data stored will be wiped out. We can make use of ",a.createElement(t.strong,null,"volumes")," to have a consistent file system that can be accessed by a database (such as Postgres) running on containers. In such cases, the database writes all data to volumes instead of container filesystem. It is not recommended to have multiple replicas of the same database container to access the same volume."),"\n",a.createElement(t.p,null,"A ",a.createElement(t.strong,null,"Volume")," in Kubernetes represents an object that allows a container to store data at the pod level, and it is ",a.createElement(t.strong,null,"not")," equivalent to a Docker Volume. It is like a data storage pocket that is tied to a specific Pod. Volumes in a Pod can be accessed by any container inside the Pod. There is a limitation: if the Pod dies, then all the volumes tied to the Pod get erased as well, and they would be re-created by Deployment along with other objects. In Kubernetes, volumes are not really appropriate to store data for a database."),"\n",a.createElement(t.p,null,"In addition to Volumes, there are 2 other types of data storage mechanisms in Kubernetes: ",a.createElement(t.strong,null,"Persistent Volume Claim")," and ",a.createElement(t.strong,null,"Persistent Volume"),". ",a.createElement(t.strong,null,"Persistent Volumes")," are a kind of long term durable storage that are not tied to any specific Pods / containers. They are separate from the Pod, unaffected by any changes in the Pod."),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Persistent Volume Claims")," advertise / specify all available Persistent Volume options inside a cluster (like options displayed on a billboard). We can create config files which list down all these options that Persistent Volume Claims can showcase to all different objects inside the cluster. They are like an advertisement that display available Volume options."),"\n",a.createElement(t.p,null,"When we request for a Persistent Volume considering the available Claims using Pod config files, Kubernetes consults the list of readily available Persistent Volumes (created ahead of time - statically provisioned), and provides the volume which can be attached to the Pod. Otherwise it creates Persistent Volumes on-the-fly (referred to as dynamically provisioned) based on request. Persistent Volume Claim Configs are attached to Pod config files. Kubernetes tries to find suitable Persistent Volume matching the config, or creates one if not found."),"\n",a.createElement(t.h4,null,"Sample Persistent Volume Claim Config"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-yaml"},'apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: somedb-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 2Gi\n# storageClassName - can be used to explicitly mention storage class to be used\n\n---\n# above config can be used in deployment file like this, which gets allocated by Kubernetes and assigned to specified container\n# ....\nspec:\n  volumes:\n    - name: postgres-storage\n      persistentVolumeClaim:\n        claimName: somedb-pvc\n  containers:\n    - name: postgres\n      image: postgres\n      ports:\n        - containerPort: 5432\n      volumeMounts:\n        - name: postgres-storage\n          mountPath: /var/lib/postgresql/data # designates where inside the container this storage should be made available\n          subPath: postgres # specifies that any data inside the container that is stored in mountPath should be stored in a folder called "postgres" in the actual PVC\n')),"\n",a.createElement(t.p,null,"There are 3 different access modes:"),"\n",a.createElement(t.ol,null,"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"ReadWriteOnce")," - can be read and written to by a single node"),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"ReadOnlyMany")," - can be read by multiple nodes"),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"ReadWriteMany")," - can be read and written to by multiple nodes at the same time"),"\n"),"\n",a.createElement(t.p,null,"Environment variables are defined in ",a.createElement(t.code,null,"spec")," using ",a.createElement(t.code,null,"env")," keyword. Each variable is defined using ",a.createElement(t.code,null,"name")," and ",a.createElement(t.code,null,"value")," attributes. Usually, the cluster IP service names of databases (defined in their metadata) would form the HOST variables in other services (example: PG_HOST). Environment variables should always be provided as strings."),"\n",a.createElement(t.h2,null,"Secrets"),"\n",a.createElement(t.p,null,"A Secret is a type of Kubernetes object which securely stores a piece of information in the cluster, such as a database password. To create a secret, use the following imperative command:"),"\n",a.createElement(t.p,null,a.createElement(t.code,null,"kubectl create secret generic <secret-name> --from-literal key=value"),", where ",a.createElement(t.code,null,"generic")," represents secret type, ",a.createElement(t.code,null,"--from-literal")," represents that secret is provided in this command instead of a file. The other secret types are ",a.createElement(t.code,null,"docker-registry")," and ",a.createElement(t.code,null,"tls"),". Multiple key-value pairs can be added in this command. ",a.createElement(t.code,null,"kubectl get secrets")," lists all secrets created in a cluster.\nExample: ",a.createElement(t.code,null,"kubectl create secret generic postgrespassword --from-literal PGPASSWD=something"),"\nThis is used in config files like this:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-yaml"},"# ...\nspec:\n  containers:\n    - name: someserver\n      env:\n        - name: REDIS_HOST\n          value: redis-cluster-ip-service\n        - name: PGPASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: postgrespassword\n              key: PGPASSWD\n# ...\n")),"\n",a.createElement(t.h2,null,"Kubernetes networking"),"\n",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 92.91666666666667%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAATABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAECAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAH3LmnRkIGgf//EABYQAQEBAAAAAAAAAAAAAAAAAEEQAP/aAAgBAQABBQJcxn//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAUEAEAAAAAAAAAAAAAAAAAAAAw/9oACAEBAAY/Ah//xAAbEAADAAIDAAAAAAAAAAAAAAAAAREQIUFRYf/aAAgBAQABPyGhPzi9DQmchpVaIf/aAAwDAQACAAMAAAAQtMd8/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPxAf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPxAf/8QAHRAAAgICAwEAAAAAAAAAAAAAAREAITFBEFFxof/aAAgBAQABPxBXSx9ji0IrjQlxsEBlRoYRgvzgiQs9QAMAT//Z\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="Kubernetes networking"\n        title=""\n        src="/ruminations/static/3324860487787e2351d85af73e28b17a/18e3b/kubernetes-networking.jpg"\n        srcset="/ruminations/static/3324860487787e2351d85af73e28b17a/46946/kubernetes-networking.jpg 240w,\n/ruminations/static/3324860487787e2351d85af73e28b17a/55489/kubernetes-networking.jpg 480w,\n/ruminations/static/3324860487787e2351d85af73e28b17a/18e3b/kubernetes-networking.jpg 960w,\n/ruminations/static/3324860487787e2351d85af73e28b17a/5a523/kubernetes-networking.jpg 1200w"\n        sizes="(max-width: 960px) 100vw, 960px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>'}}),"\n",a.createElement(t.p,null,"Every Pod in a cluster gets its own unique cluster-wide IP address. This means we do not need to explicitly create links between Pods and we almost never need to deal with mapping container ports to host ports.\nThis creates a clean, backwards-compatible model where Pods can be treated much like VMs or physical hosts from the perspectives of port allocation, naming, service discovery, load balancing, application configuration, and migration."),"\n",a.createElement(t.p,null,"Kubernetes imposes the following fundamental requirements on any networking implementation (barring any intentional network segmentation policies):"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"pods can communicate with all other pods on any other node without NAT"),"\n",a.createElement(t.li,null,"agents on a node (e.g. system daemons, kubelet) can communicate with all pods on that node"),"\n"),"\n",a.createElement(t.p,null,"Note: For those platforms that support Pods running in the host network (e.g. Linux), when pods are attached to the host network of a node they can still communicate with all pods on all nodes without NAT."),"\n",a.createElement(t.p,null,"Kubernetes IP addresses exist at the ",a.createElement(t.code,null,"Pod")," scope - containers within a ",a.createElement(t.code,null,"Pod")," share their network namespaces - including their IP address and MAC address. This means that containers within a ",a.createElement(t.code,null,"Pod")," can all reach each other's ports on ",a.createElement(t.code,null,"localhost"),". This also means that containers within a ",a.createElement(t.code,null,"Pod"),' must coordinate port usage, but this is no different from processes in a VM. This is called the "IP-per-pod" model.'),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"LoadBalancer")," - is another type of Kubernetes Service which is an old way of getting network traffic into a cluster. Ingress service is the new method of setting up incoming network into the cluster. A LoadBalancer allows access to one specific set of pods in our application only. Kubernetes also configures cloud provider-specific load balancer setups when this is initialized, and connects them to the cluster."),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"Ingress")," - a Kubernetes Service which exposes a set of services to the outside world and allow users to access all the pods configured in the cluster. There are several different implementations of Ingress. Nginx Ingress is one of them, which is a community-led project (",a.createElement(t.a,{href:"https://github.com/kubernetes/ingress-nginx"},a.createElement(t.strong,null,"ingress-nginx")),") and frequently used. Another implementation available is ",a.createElement(t.a,{href:"https://github.com/nginxinc/kubernetes-ingress"},a.createElement(t.strong,null,"kubernetes-ingress")),", which is led by the company Nginx. Setup of ingress-nginx varies depending on the environment (local / cloud provider). The Ingress config files describe a set of routing rules to take incoming traffic and send it to the correct services inside the cluster. When these files are provided to kubectl, it creates an ingress controller, which creates a pod running Ngnix containing a particular set of rules based on the configuration provided. The ingress controller watches for changes to ingress config files and updates the pod that handles incoming traffic. In the case of ",a.createElement(t.code,null,"ingress-nginx"),", both of these (ingress-controller and pod handling incoming traffic) are the same."),"\n",a.createElement(t.p,null,"In Google Cloud, the setup consists of a ",a.createElement(t.strong,null,"cloud-native load balancer")," which forwards incoming traffic to a LoadBalancer service connected to a Deployment based on Ingress Config file (which deploys ",a.createElement(t.code,null,"nginx-controller/nginx")," pod based on config rules). The Nginx pod is responsible for routing traffic to appropriate services inside the cluster. Also, another Deployment is set up, called ",a.createElement(t.strong,null,"default backend")," (Pod with ClusterIP service). The default backend is used for a series of healthchecks to make sure the cluster is up and running. Ideally the default backend would be replaced with backend server (Express, FastAPI etc.)."),"\n",a.createElement(t.p,null,"The ",a.createElement(t.code,null,"nginx-controller/nginx")," image is used for the pod connected to LoadBalancer service instead of default nginx image. This is because the image has additional configuration to operate inside Kubernetes clusters, like routing incoming traffic to the pods directly instead of ClusterIP services to allow for features like sticky sessions etc. The ingress service automatically listens on ports 80 and 443. The Nginx configuration by default chooses HTTPS connection using a dummy certificate."),"\n",a.createElement(t.p,null,"Sample Ingress config:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-yaml"},"apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: ingress-service\n  annotations: # they are additional configuration options that specify higher level setup around the created ingress object.\n    kubernetes.io/ingress.class: nginx # creates ingress-controller based on nginx project\n    nginx.ingress.kubernetes.io/rewrite-target: / # remove additional route urls after / before sending the request to pods. Example: it rewrites /api to /\nspec:\n  rules:\n    - http:\n        paths: # requests should be routed to the following paths\n          - path: /\n            backend:\n              serviceName: client-cluster-ip-service\n              servicePort: 3000\n          - path: /api/\n            backend:\n              serviceName: server-cluster-ip-service\n              servicePort: 5000\n")),"\n",a.createElement(t.blockquote,null,"\n",a.createElement(t.h3,null,"Why Google Cloud is preferred for Kubernetes than AWS"),"\n",a.createElement(t.p,null,'Google created Kubernetes - the open source project and financially supported it for the first few years of its existence. AWS got Kubernetes support in early 2018. Google Cloud offers "cloud console" - a terminal connected to all resources hosted there which also provides access to a kubectl-like tool connected to production Kubernetes instance. Documentation for Kubernetes in Google Cloud is much better compared to AWS.'),"\n"),"\n",a.createElement(t.h4,null,"Things to note in GKE console"),"\n",a.createElement(t.p,null,"Node configuration (node pool) displayed in the console describes specifications of each different virtual machine that will be added to Kubernetes Cluster as a Node. The default storage class is standard with a provisioner of ",a.createElement(t.code,null,"kubernetes.io/gce-pd"),". GKE enables RBAC by default. Role Based Access Control (RBAC) limits who can access and modify objects in Kubernetes cluster. RBAC terminologies in a Kubernetes Cluster:"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"User Accounts")," identify a person administering the Kubernetes cluster"),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Service Accounts")," identify a pod administering the cluster"),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"ClusterRoleBinding")," authorizes an account (user / service) to do a certain set of actions across the entire cluster"),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"RoleBinding"),' authorizes an account to do a certain set of actions in a "single namespace"'),"\n"),"\n",a.createElement(t.h2,null,"Helm and cert-manager"),"\n",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 51.25000000000001%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsSAAALEgHS3X78AAABoUlEQVR42n2R2W7UQBBF55P5HP4CgZCQIngEAZMojIJmHK/jZeK2u+3e3LZ7ddoeEaQ8pEq6T3Xq1lXtCoZTSjJGYtzfpfEhz76Gadr1y7I457xa62Kg0tZmrbwLwO2pOUTtt3v46SfdnT2MadzRivGS0gtjD20LBr7BXhZjXQR0UKl9OObtXEBZIXmq5H0mdxntg0b8BYawkVPCKa0oQZNY4ZVdlHFlZz58Z+/eo7wepwHLaUBMp43aVQwnHYF8yDltBkYEL2jfz/9h75w0Zh9NH38Mp3Ys8QyJOkMVA73bhpzVCoiBz5Mx5sq8lIfDWqfQlcj8yoc/xRRc9GNt03aD19ukRJxzITx89XxZobfMEXDHUv5O6eHMg4sKgUubDZZKS6mI1spaa4yXV84PpYpqlTVzgGTemQrpBOjkCt+G5ed9oLTGGFutn4Q4jxOZZ858cyjVTTbenMov+6OYleBssQYyE9ZqhTETT8gbe3/plU1zJ6btw9a/Whn7CExwEccCN0S3WCKqcqjj5l/mN8pv8PEy6HLoEmDixsSr2hyZZ/+HM1qq2z0sAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="Helm"\n        title=""\n        src="/ruminations/static/75e5e6e597276ad1fa719b99b22c266e/7d769/helm.png"\n        srcset="/ruminations/static/75e5e6e597276ad1fa719b99b22c266e/5243c/helm.png 240w,\n/ruminations/static/75e5e6e597276ad1fa719b99b22c266e/ab158/helm.png 480w,\n/ruminations/static/75e5e6e597276ad1fa719b99b22c266e/7d769/helm.png 960w,\n/ruminations/static/75e5e6e597276ad1fa719b99b22c266e/4af54/helm.png 1400w"\n        sizes="(max-width: 960px) 100vw, 960px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>'}}),"\n",a.createElement(t.p,null,"Helm is a program that we can use to install and administer third-party software inside the Kubernetes cluster. When Helm is installed, ",a.createElement(t.strong,null,"Helm Client (CLI tool)")," and ",a.createElement(t.strong,null,"Tiller Server")," are installed as part of it. ",a.createElement(t.strong,null,"Tiller")," is a server pod running inside the Kubernetes cluster, which is responsible for modifying the cluster to install additional programs in it. After installing tiller and assigning proper permissions, initialize it by using ",a.createElement(t.code,null,"helm init --service-account tiller upgrade"),"."),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,a.createElement(t.code,null,"kubectl create serviceaccount --namespace kube-system tiller")," - creates a new service account named ",a.createElement(t.strong,null,"tiller")," in the kube-system namespace"),"\n",a.createElement(t.li,null,a.createElement(t.code,null,"kubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller")," - creates a new clusterrolebinding with the (pre-defined) role ",a.createElement(t.code,null,"cluster-admin")," and assign it to service account ",a.createElement(t.strong,null,"tiller")),"\n"),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"cert-manager")," adds certificates and certificate issuers as resource types in Kubernetes clusters, and simplifies the process of obtaining, renewing and using those certificates. It can issue certificates from a variety of supported sources, including Let's Encrypt, HashiCorp Vault, and Venafi as well as private PKI. It will ensure certificates are valid and up to date, and attempt to renew certificates at a configured time before expiry. The ingress service should be updated once the certificates are retrieved."),"\n",a.createElement(t.p,null,"cert-manager is installed via Helm, which installs certain Kubernetes objects via a Deployment, creating certain Pods, Service Account and Cluster Role Bindings. In addition to this, the following objects need to be installed:"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Certificate")," - object describing details about the certificate that should be obtained. It is linked to a Secret once the certificate is retrieved."),"\n",a.createElement(t.li,null,a.createElement(t.strong,null,"Issuer")," - object telling cert-manager where to get the certificate from (a certificate authority)"),"\n"),"\n",a.createElement(t.p,null,"Sample config file for Issuer:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-yaml"},'apiVersion: certmanager.k8s.io/v1alpha1\nkind: ClusterIssuer\nmetadata:\n  name: letsencrypt-prod # can be named after the source of the issuer\nspec:\n  acme:\n    server: https://acme-v02.api.letsencrypt.org/directory # link to the api to setup issuer communication\n    email: "abc@abc.com"\n    privateKeySecretRef:\n      name: letsencrypt-prod\n    http01: {} # basically specifies that we want to use http process for getting a certificate\n')),"\n",a.createElement(t.hr),"\n",a.createElement(t.p,null,"Sample config file for Certificate:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-yaml"},"apiVersion: certmanager.k8s.io/v1alpha1\nkind: Certificate\nmetadata:\n  name: k8s-sample-com-tls\nspec:\n  secretName: k8s-sample-com # can be anything; specifies where the certificate should be stored after it is obtained by cert-manager\n  issuerRef: # reference to the Issuer that is already set up\n    name: letsencrypt-prod\n    kind: ClusterIssuer\n  commonName: k8s-sample.com # domain name\n  dnsNames: # list of all different domains that should be associated with the certificate\n    - k8s-sample.com\n    - www.k8s-sample.com\n  acme:\n    config:\n      - http01:\n          ingressClass: nginx\n        domains: # list of all domains that should go through verification process\n          - k8s-sample.com\n          - www.k8s-sample.com\n")),"\n",a.createElement(t.h3,null,"Skaffold"),"\n",a.createElement(t.p,null,"Skaffold is a command-line tool completely separate from Kubernetes which facilitates local development. It watches local directory for changes and update that in Kubernetes cluster using one of the following methods:"),"\n",a.createElement(t.ol,null,"\n",a.createElement(t.li,null,"Rebuilding client image from scratch and then updating Kubernetes cluster"),"\n",a.createElement(t.li,null,"Injecting updated files into the Client pod and rely on the application to automatically update itself"),"\n"),"\n",a.createElement(t.p,null,"Sample Skaffold config file:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-yaml"},'apiVersion: skaffold/v1beta2\nkind: Config\nbuild: # lists out all different deployments that should be managed by Skaffold\n  local:\n    push: false # by default Skaffold pushes built image to DockerHub, which can be disabled like this\n  artifacts:\n    - image: someuser/multi-client\n      context: client # folder where the Docker image will be built\n      docker:\n        dockerfile: Dockerfile.dev\n      sync: # series of matching file paths that informs Skaffold to watch for changes and sync them without rebuilding the image\n        "**/*.js": .\n        "**/*.css": .\n        "**/*.html": .\n    - image: someuser/multi-server\n      context: server\n      docker:\n        dockerfile: Dockerfile.dev\n      sync:\n        "**/*.js": .\n    - image: someuser/multi-worker\n      context: worker\n      docker:\n        dockerfile: Dockerfile.dev\n      sync:\n        "**/*.js": .\ndeploy:\n  kubectl:\n    manifests: # all Kubernetes config files that should be managed by Skaffold\n      - k8s/client-deployment.yaml\n      - k8s/server-deployment.yaml\n      - k8s/worker-deployment.yaml\n      - k8s/server-cluster-ip-service.yaml\n      - k8s/client-cluster-ip-service.yaml\n')),"\n",a.createElement(t.p,null,"Skaffold falls back to 1st method (rebuilding image from scratch) whenever any file which isn't specified in the config gets changed. It can be started by using ",a.createElement(t.code,null,"skaffold dev"),". It automatically creates and deletes all Kubernetes resources specified in the config file when it is started and shutdown. It can also handle Kubernetes resources in its configuration that are already up and running."),"\n",a.createElement(t.h2,null,"Credits & Attributions:"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,a.createElement(t.a,{href:"https://kubernetes.io/docs/home/"},"Official Kubernetes Documentation")),"\n",a.createElement(t.li,null,a.createElement(t.a,{href:"https://cert-manager.io/docs/"},"cert-manager Documentation")),"\n",a.createElement(t.li,null,a.createElement(t.a,{href:"https://skaffold.dev/docs/"},"Skaffold Documentation")),"\n",a.createElement(t.li,null,a.createElement(t.a,{href:"https://www.udemy.com/course/docker-and-kubernetes-the-complete-guide/"},"Docker and Kubernetes: The Complete Guide by Stephen Grider")),"\n"))}var o=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,l.RP)(),e.components);return t?a.createElement(t,e,a.createElement(s,e)):s(e)},r=n(1173);function i(e){return a.createElement(r.A,e,a.createElement(o,e))}r.A},7715:function(e,t,n){var a=n(557),l=n(6540),s=n(4794),o=n(3601),r=n(2174);t.A=e=>{let{tags:t}=e;const{tagsPath:n,basePath:i}=(0,o.A)();return(0,a.Y)(l.Fragment,null,t.map((e,t)=>(0,a.Y)(l.Fragment,{key:e.slug},!!t&&", ",(0,a.Y)(s.Link,{sx:e=>{var t;return Object.assign({},null===(t=e.styles)||void 0===t?void 0:t.a)},to:(0,r.A)("/"+i+"/"+n+"/"+e.slug)},e.name))))}}}]);
//# sourceMappingURL=component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx-content-file-path-content-posts-kubernetes-reference-index-mdx-b3c684f147c6d40d7c78.js.map